# Extending SqlDelight

SqlDelight supports different sql dialects and drivers.
Besides the official modules, it is possible to write and use your own [dialects](dialects) or drivers.

## Custom Drivers

The driver handles the connection to your underlying database and executes the sql statements.
SqlDelight defines the required interface your driver must implement: `SqlDriver`.

Use your new driver like a normal Gradle dependency:

=== "Kotlin"

```kotlin
dependencies {
    implementation("com.example:your-driver:version")
}
```

=== "Groovy"

```groovy
dependencies {
    testImplementation "com.example:your-driver:version"
}
```

And use it in your code:

```kotlin
val yourDriver: SqlDriver = YourDriver()
val db = Database(yourDriver)
```

### Use database-specific types

Depending on your use-case you might want to use database-specific types, for example, Postgres supports a native UUID
type.

To bind custom types to your statements, you need to extend the `SqlPreparedStatement` with your custom binding methods:

```kotlin
class YourPreparedStatements : SqlPreparedStatement {
    fun bindUuid(index: Int, value: UUID) {}
}
```

The index is the zero-based index of the parameter.

To get the custom type, you also need to extend the `SqlCursor` with custom get methods:

```kotlin
class YourCursor : SqlCursor {
    fun getUuid(index: Int): UUID {}
}
```

If you want to use these binding and get methods with code generated by SqlDelight, you need a [custom dialect](dialects) too
