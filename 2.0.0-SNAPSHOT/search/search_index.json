{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLDelight generates typesafe kotlin APIs from your SQL statements. It verifies your schema, statements, and migrations at compile-time and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight understands your existing SQL schema. CREATE TABLE hockey_player ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , name TEXT NOT NULL , number INTEGER NOT NULL ); It generates typesafe code for any labeled SQL statements. SQLDelight supports a variety of dialects and platforms: SQLite Android Native (iOS, macOS, or Windows) JVM Javascript Multiplatform MySQL (JVM) PostgreSQL (JVM) (Experimental) HSQL/H2 (JVM) (Experimental) Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository . Note that all coordinates are app.cash.sqldelight instead of com.squareup.sqldelight for 2.0.0+ SNAPSHOTs. Kotlin Groovy // settings.gradle.kts pluginManagement { repositories { gradlePluginPortal () maven ( url = \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } // build.gradle.kts plugins { id ( \"app.cash.sqldelight\" ) version \"SNAPSHOT-VERSION\" } repositories { maven ( url = \"https://oss.sonatype.org/content/repositories/snapshots\" ) } // settings.gradle pluginManagement { repositories { gradlePluginPortal () maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } } // build.gradle plugins { id \"app.cash.sqldelight\" version \"SNAPSHOT-VERSION\" } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } Alpha IDE plugins are also available by using the alpha channel in IntelliJ: https://plugins.jetbrains.com/plugins/alpha/com.squareup.sqldelight . Snapshots are also available in the EAP channel: https://plugins.jetbrains.com/plugins/eap/com.squareup.sqldelight","title":"Overview"},{"location":"#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository . Note that all coordinates are app.cash.sqldelight instead of com.squareup.sqldelight for 2.0.0+ SNAPSHOTs. Kotlin Groovy // settings.gradle.kts pluginManagement { repositories { gradlePluginPortal () maven ( url = \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } // build.gradle.kts plugins { id ( \"app.cash.sqldelight\" ) version \"SNAPSHOT-VERSION\" } repositories { maven ( url = \"https://oss.sonatype.org/content/repositories/snapshots\" ) } // settings.gradle pluginManagement { repositories { gradlePluginPortal () maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } } // build.gradle plugins { id \"app.cash.sqldelight\" version \"SNAPSHOT-VERSION\" } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } Alpha IDE plugins are also available by using the alpha channel in IntelliJ: https://plugins.jetbrains.com/plugins/alpha/com.squareup.sqldelight . Snapshots are also available in the EAP channel: https://plugins.jetbrains.com/plugins/eap/com.squareup.sqldelight","title":"Snapshots"},{"location":"changelog/","text":"Change Log [2.0.0-alpha04] - 2022-10-03 Breaking Changes The Paging 3 extension API has changed to only allow int types for the count. The coroutines extension now requires a dispatcher to be passed in instead of defaulting. Dialect and Driver classes are final, use delegation instead. Added [HSQL Dialect] Hsql: Support using DEFAULT for generated columns in Insert (#3372 by Philip Wedemann ) [PostgreSQL Dialect] PostgreSQL: Support using DEFAULT for generated columns in INSERT (#3373 by Philip Wedemann ) [PostgreSQL Dialect] Add NOW() to PostgreSQL (#3403 by Philip Wedemann ) [PostgreSQL Dialect] PostgreSQL Add NOT operator (#3504 by Philip Wedemann ) [Paging] Allow passing in CoroutineContext to *QueryPagingSource (#3384) [Gradle Plugin] Add better version catalog support for dialects (#3435) [Native Driver] Add callback to hook into DatabaseConfiguration creation of NativeSqliteDriver (#3512 by Sven Jacobs ) Changed [Paging] Add a default dispatcher to the KeyedQueryPagingSource backed QueryPagingSource function (#3385) [Paging] Make OffsetQueryPagingSource only work with Int (#3386) [Async Runtime] Move await* to upper class ExecutableQuery (#3524 by Philip Wedemann ) [Coroutines Extensions] Remove default params to flow extensions (#3489) Fixed [Gradle Plugin] Update to Kotlin 1.7.20 (#3542 by Zac Sweers ) [R2DBC Driver] Adopt R2DBC changes which do not always send a value (#3525 by Philip Wedemann ) [HSQL Dialect] Fix failing sqlite VerifyMigrationTask with Hsql (#3380 by Philip Wedemann ) [Gradle Plugin] Convert tasks to use lazy configuration API (by Matthew Haughton ) [Gradle Plugin] Avoid NPEs in Kotlin 1.7.20 (#3398 by Zac Sweers ) [Gradle Plugin] Fix description of squash migrations task (#3449) [IDE Plugin] Fix NoSuchFieldError in newer Kotlin plugins (#3422 by Madis Pink ) [IDE Plugin] IDEA: UnusedQueryInspection - fix ArrayIndexOutOfBoundsException. (#3427 by Niklas Baudy ) [IDE Plugin] Use reflection for old kotlin plugin references [Compiler] Custom dialect with extension function don't create imports (#3338 by Philip Wedemann ) [Compiler] Fix escaping CodeBlock.of(\"${CodeBlock.toString()}\") (#3340 by Philip Wedemann ) [Compiler] Await async execute statements in migrations (#3352) [Compiler] Fix AS (#3370 by Philip Wedemann ) [Compiler] getObject method supports automatic filling of the actual type. (#3401 by Rob X ) [Compiler] Fix codegen for async grouped returning statements (#3411) [Compiler] Infer the Kotlin type of bind parameter, if possible, or fail with a better error message (#3413 by Philip Wedemann ) [Compiler] Don't allow ABS(\"foo\") (#3430 by Philip Wedemann ) [Compiler] Support inferring kotlin type from other parameters (#3431 by Philip Wedemann ) [Compiler] Always create the database implementation (#3540 by Philip Wedemann ) [Compiler] Relax javaDoc and add it to custom mapper function too (#3554 Philip Wedemann ) [Compiler] Fix DEFAULT in binding (by Philip Wedemann ) [Paging] Fix Paging 3 (#3396) [Paging] Allow construction of OffsetQueryPagingSource with Long (#3409) [Paging] Don't statically swap Dispatchers.Main (#3428) [2.0.0-alpha03] - 2022-06-17 Breaking Changes Dialects are now references like actual gradle dependencies. sqldelight { MyDatabase { dialect ( \"app.cash.sqldelight:postgres-dialect:2.0.0-alpha03\" ) } } The AfterVersionWithDriver type was removed in favour of AfterVersion which now always has the driver. The Schema type is no longer a subtype of SqlDriver PreparedStatement APIs are now called with zero-based indexes. Added [IDE Plugin] Added support for running SQLite, MySQL, and PostgreSQL commands against a running database (#2718 by Alexander Perfilyev ) [IDE Plugin] Add support for the android studio DB inspector (#3107 by Alexander Perfilyev ) [Runtime] Add support for async drivers (#3168 by Derek Ellis ) [Native Driver] Support new kotlin native memory model (#3177 by Kevin Galligan ) [JS Driver] Add a driver for SqlJs workers (#3203 by Derek Ellis ) [Gradle Plugin] Expose the classpath for SQLDelight tasks [Gradle Plugin] Add a gradle task for squashing migrations [Gradle Plugin] Add a flag to ignore schema definitions during migration checks [MySQL Dialect] Support FOR SHARE and FOR UPDATE in MySQL (#3098) [MySQL Dialect] Support MySQL index hints (#3099) [PostgreSQL Dialect] Add date_trunc (#3295 by Philip Wedemann ) [JSON Extensions] Support JSON table functions (#3090) Changed [Runtime] Remove the AfterVersion type without the driver (#3091) [Runtime] Move Schema type to top-level [Runtime] Open dialect and resolver to support 3rd party implementations (#3232 by Philip Wedemann ) [Compiler] Include the dialect used to compile in failure reports (#3086) [Compiler] Skip unused adapters (#3162 by Eliezer Graber ) [Compiler] Use zero based index in PrepareStatement (#3269 by Philip Wedemann ) [Gradle Plugin] Also make the dialect a proper gradle dependency instead of a string (#3085) [Gradle Plugin] Gradle Verify Task: Throw when missing database file. (#3126 by Niklas Baudy ) Fixed [Gradle Plugin] Minor cleanups and tweaks to the Gradle plugin (#3171 by Matthew Haughton ) [Gradle Plugin] Dont use an AGP string for the generated directory [Gradle Plugin] Use AGP namespace attribute (#3220) [Gradle Plugin] Do not add kotlin-stdlib as a runtime dependency of the Gradle plugin (#3245 by [Martin Bonnin][mbonnin]) [Gradle Plugin] Simplify the multiplatform configuration (#3246 by [Martin Bonnin][mbonnin]) [Gradle Plugin] Support js only projects (#3310 by Philip Wedemann ) [IDE Plugin] Use java home for gradle tooling API (#3078) [IDE Plugin] Load the JDBC driver on the correct classLoader inside the IDE plugin (#3080) [IDE Plugin] Mark the file element as null before invalidating to avoid errors during already existing PSI changes (#3082) [IDE Plugin] Dont crash finding usages of the new table name in an ALTER TABLE statement (#3106) [IDE Plugin] Optimize the inspectors and enable them to fail silently for expected exception types (#3121) [IDE Plugin] Delete files that should be generated directories (#3198) [IDE Plugin] Fix a not-safe operator call [Compiler] Ensure updates and deletes with RETURNING statements execute queries. (#3084) [Compiler] Correctly infer argument types in compound selects (#3096) [Compiler] Common tables do not generate data classes so dont return them (#3097) [Compiler] Find the top migration file faster (#3108) [Compiler] Properly inherit nullability on the pipe operator [Compiler] Support the iif ANSI SQL function [Compiler] Don't generate empty query files (#3300 by Philip Wedemann ) [Compiler] Fix adapter with question mark only (#3314 by Philip Wedemann ) [PostgreSQL Dialect] Postgres primary key columns are always non-null (#3092) [PostgreSQL Dialect] Fix copy with same name in multiple tables (#3297 by Philip Wedemann ) [SQLite 3.35 Dialect] Only show an error when dropping an indexed column from the altered table (#3158 by Eliezer Graber ) [2.0.0-alpha02] - 2022-04-13 Breaking Changes You'll need to replace all occurrences of app.cash.sqldelight.runtime.rx with app.cash.sqldelight.rx2 Added [Compiler] Support returning at the end of a grouped statement [Compiler] Support compiler extensions via dialect modules and add a SQLite JSON extension (#1379, #2087) [Compiler] Support PRAGMA statements which return a value (#1106) [Compiler] Support generating value types for marked columns [Compiler] Add support for optimistic locks and validation (#1952) [Compiler] Support multi-update statements [PostgreSQL] Support postgres returning statements [PostgreSQL] Support postgres date types [PostgreSQL] Support pg intervals [PostgreSQL] Support PG Booleans and fix inserts on alter tables [PostgreSQL] Support optional limits in Postgres [PostgreSQL] Support PG BYTEA type [PostgreSQL] Add a test for postgres serials [PostgreSQL] Support for update postgres syntax [PostgreSQL] Support PostgreSQL array types [PostgreSQL] Properly store/retrieve UUID types in PG [PostgreSQL] Support PostgreSQL NUMERIC type (#1882) [PostgreSQL] Support returning queries inside of common table expressions (#2471) [PostgreSQL] Support json specific operators [PostgreSQL] Add Postgres Copy (by Philip Wedemann ) [MySQL] Support MySQL Replace [MySQL] Support NUMERIC/BigDecimal MySQL types (#2051) [MySQL] Support MySQL truncate statement [MySQL] Support json specific operators in Mysql (by Eliezer Graber ) [MySQL] Support MySql INTERVAL (#2969 by Eliezer Graber ) [HSQL] Add HSQL Window functionality [SQLite] Don't replace equality checks for nullable parameters in a WHERE (#1490 by Eliezer Graber ) [SQLite] Support Sqlite 3.35 returning statements (#1490 by Eliezer Graber ) [SQLite] Support GENERATED clause [SQLite] Add support for Sqlite 3.38 dialect (by Eliezer Graber ) Changed [Compiler] Clean up generated code a bit [Compiler] Forbid usage of table parameters in grouped statements (#1822) [Compiler] Put grouped queries inside a transaction (#2785) [Runtime] Return the updated row count from the drivers execute method [Runtime] Confine SqlCursor to the critical section accessing the connection. (#2123 by Anders Ha ) [Gradle Plugin] Compare schema definitions for migrations (#841) [PostgreSQL] Disallow double quotes for PG [MySQL] Error on usage of == in MySQL (#2673) Fixed [Compiler] Same adapter type from different tables causing a compilation error in 2.0 alpha [Compiler] Problem compiling upsert statement (#2791) [Compiler] Query result should use tables in the select if there are multiple matches (#1874, #2313) [Compiler] Support updating a view which has a INSTEAD OF trigger (#1018) [Compiler] Support from and for in function names [Compiler] Allow SEPARATOR keyword in function expressions [Compiler] Cannot access ROWID of aliased table in ORDER BY [Compiler] Aliased column name is not recognized in HAVING clause in MySQL [Compiler] Erroneous 'Multiple columns found' error [Compiler] Unable to set PRAGMA locking_mode = EXCLUSIVE; [PostgreSQL] Postgresql rename column [MySQL] UNIX_TIMESTAMP, TO_SECONDS, JSON_ARRAYAGG MySQL functions not recognized [SQLite] fix SQLite window functionality [IDE Plugin] Run the goto handler in an empty progress indicator (#2990) [IDE Plugin] Ensure the highlight visitor doesnt run if the project isnt configured (#2981, #2976) [IDE Plugin] Ensure transitive generated code is also updated in the IDE (#1837) [IDE Plugin] Invalidate indexes when updating the dialect [2.0.0-alpha01] - 2022-03-31 This is the first alpha release for 2.0 and has some breaking changes. We expect more ABI breaking changes to come so don't publish any libraries with dependencies on this release (applications should be fine). Breaking Changes First, you'll need to replace all occurrences of com.squareup.sqldelight with app.cash.sqldelight Second, you'll need to replace all occurrences of app.cash.sqldelight.android with app.cash.sqldelight.driver.android Third, you'll need to replace all occurrences of app.cash.sqldelight.sqlite.driver with app.cash.sqldelight.driver.jdbc.sqlite Fourth, you'll need to replace all occurrences of app.cash.sqldelight.drivers.native with app.cash.sqldelight.driver.native The IDE plugin must be updated to a 2.X version, which can be found in the alpha or eap channel Dialects are now dependencies which you can specify within gradle: sqldelight { MyDatabase { packageName = \"com.example\" dialect = \"app.cash.sqldelight:mysql-dialect:2.0.0-alpha01\" } } The currently supported dialects are mysql-dialect , postgresql-dialect , hsql-dialect , sqlite-3-18-dialect , sqlite-3-24-dialect , sqlite-3-25-dialect , sqlite-3-30-dialect , and sqlite-3-35-dialect Primitive types must now be imported (for example INTEGER AS Boolean you have to import kotlin.Boolean ), some previously supported types now need an adapter. Primitive adapters are available in app.cash.sqldelight:primitive-adapters:2.0.0-alpha01 for most conversions (like IntColumnAdapter for doing Integer AS kotlin.Int ). Added [IDE Plugin] Basic suggested migration (by Alexander Perfilyev ) [IDE Plugin] Add import hint action (by Alexander Perfilyev ) [IDE Plugin] Add kotlin class completion (by Alexander Perfilyev ) [Gradle Plugin] Add shortcut for Gradle type safe project accessors (by Philip Wedemann ) [Compiler] Customize codegen based on dialect (by Marius Volkhart ) [JDBC Driver] Add common types to JdbcDriver (by Marius Volkhart ) [SQLite] Add support for the sqlite 3.35 (by Eliezer Graber ) [SQLite] Add support for ALTER TABLE DROP COLUMN (by Eliezer Graber ) [SQLite] Add support for Sqlite 3.30 dialect (by Eliezer Graber ) [SQLite] Support NULLS FIRST/LAST in sqlite (by Eliezer Graber ) [HSQL] Add HSQL support for generated clause (by Marius Volkhart ) [HSQL] Add support for named parameters in HSQL (by Marius Volkhart ) [HSQL] Customize the HSQL insert query (by Marius Volkhart ) Changed [Everything] Package name has changed from com.squareup.sqldelight to app.cash.sqldelight. [Runtime] Move dialects into their own isolated gradle modules [Runtime] Switch to driver-implemented query notifications. [Runtime] Extract default column adapters to separate module (#2056, #2060) [Compiler] Let modules generate the queries implementations instead of redoing it in each module [Compiler] Remove the custom toString generation of generated data classes. (by Paul Woitaschek ) [JS Driver] Remove sql.js dependency from sqljs-driver (by Derek Ellis ) [Paging] Remove the android paging 2 extension [IDE Plugin] Add an editor banner while SQLDelight is syncing (#2511) [IDE Plugin] Minimum supported IntelliJ version is 2021.1 Fixed [Runtime] Flatten listener list to reduce allocations and pointer chasing. (by Anders Ha ) [IDE Plugin] Fix error message to allow jumping to error (by Philip Wedemann ) [IDE Plugin] Add missing inspection descriptions (#2768 by Alexander Perfilyev ) [IDE Plugin] Fix exception in GotoDeclarationHandler (#2531, #2688, #2804 by Alexander Perfilyev ) [IDE Plugin] Highlight import keyword (by Alexander Perfilyev ) [IDE Plugin] Fix unresolved kotlin types (#1678 by Alexander Perfilyev ) [IDE Plugin] Fix highlighting for unresolved package (#2543 by Alexander Perfilyev ) [IDE Plugin] Dont attempt to inspect mismatched columns if the project index is not yet initialized [IDE Plugin] Dont initialize the file index until a gradle sync has occurred [IDE Plugin] Cancel the SQLDelight import if a gradle sync begins [IDE Plugin] Regenerate the database outside of the thread an undo action is performed on [IDE Plugin] If a reference cannot be resolves use a blank java type [IDE Plugin] Correctly move off the main thread during file parsing and only move back on to write [IDE Plugin] Improve compatibility with older IntelliJ versions (by Matthew Haughton ) [IDE Plugin] Use faster annotation API [Gradle Plugin] Explicitly support js/android plugins when adding runtime (by Zac Sweers ) [Gradle Plugin] Register migration output task without derviving schemas from migrations (#2744 by Kevin Cianfarini ) [Gradle Plugin] If the migration task crashes, print the file it crashed running [Gradle Plugin] Sort files when generating code to ensure idempotent outputs (by Zac Sweers ) [Compiler] Use faster APIs for iterating files and dont explore the entire PSI graph [Compiler] Add keyword mangling to select function parameters (#2759 by Alexander Perfilyev ) [Compiler] Fix packageName for migration adapter (by Philip Wedemann ) [Compiler] Emit annotations on properties instead of types (#2798 by Alexander Perfilyev ) [Compiler] Sort arguments before passing to a Query subtype (#2379 by Alexander Perfilyev ) [1.5.3] - 2021-11-23 Added [JDBC Driver] Open JdbcDriver for 3rd party driver implementations (#2672 by Philip Wedemann ) [MySQL Dialect] Add missing functions for time increments (#2671 by Sam Doward ) [Coroutines Extension] Add M1 targets for coroutines-extensions (by Philip Dukhov ) Changed [Paging3 Extension] Distribute sqldelight-android-paging3 as JAR instead of AAR (#2634 by Marco Romano ) Property names which are also soft keywords will now be suffixed with underscores. For instance value will be exposed as value_ Fixed [Compiler] Don't extract variables for duplicate array parameters (by Alexander Perfilyev ) [Gradle Plugin] add kotlin.mpp.enableCompatibilityMetadataVariant. (#2628 by Martin Bonnin ) [IDE Plugin] Find usages processing requires a read action [1.5.2] - 2021-10-12 Added [Gradle Plugin] HMPP support (#2548 by Martin Bonnin ) [IDE Plugin] Add NULL comparison inspection (by Alexander Perfilyev ) [IDE Plugin] Add inspection suppressor (#2519 by Alexander Perfilyev ) [IDE Plugin] Mixed named and positional parameters inspection (by Alexander Perfilyev ) [SQLite Driver] Add mingwX86 target. (#2558 by Nikita Kozhemyakin ) [SQLite Driver] Add M1 targets [SQLite Driver] Add linuxX64 support (#2456 by Cedric Hippmann ) [MySQL Dialect] Add ROW_COUNT function to mysql (#2523) [PostgreSQL Dialect] postgres rename, drop column (by Juan Liska ) [PostgreSQL Dialect] PostgreSQL grammar doesn't recognize CITEXT [PostgreSQL Dialect] Include TIMESTAMP WITH TIME ZONE and TIMESTAMPTZ [PostgreSQL Dialect] Add grammar for PostgreSQL GENERATED columns [Runtime] Provide SqlDriver as a parameter to AfterVersion (#2534, 2614 by Ahmed El-Helw ) Changed [Gradle Plugin] explicitely require Gradle 7.0 (#2572 by Martin Bonnin ) [Gradle Plugin] Make VerifyMigrationTask support Gradle's up-to-date checks (#2533 by Matthew Haughton ) [IDE Plugin] Don't warn with \"Join compares two columns of different types\" when joining nullable with non-nullable type (#2550 by Piotr Chmielowski ) [IDE Plugin] Clarify the error for the lowercase 'as' in column type (by Alexander Perfilyev ) Fixed [IDE Plugin] Do not reparse under a new dialect if the project is already disposed (#2609) [IDE Plugin] If the associated virtual file is null, the module is null (#2607) [IDE Plugin] Avoid crashing during the unused query inspection (#2610) [IDE Plugin] Run the database sync write inside of a write action (#2605) [IDE Plugin] Let the IDE schedule SQLDelight syncronization [IDE Plugin] Fix npe in JavaTypeMixin (#2603 by Alexander Perfilyev ) [IDE Plugin] Fix IndexOutOfBoundsException in MismatchJoinColumnInspection (#2602 by Alexander Perfilyev ) [IDE Plugin] Add description for UnusedColumnInspection (#2600 by Alexander Perfilyev ) [IDE Plugin] Wrap PsiElement.generatedVirtualFiles into read action (#2599 by Alexander Perfilyev ) [IDE Plugin] Remove unnecessary nonnull cast (#2596) [IDE Plugin] Properly handle nulls for find usages (#2595) [IDE Plugin] Fix IDE autocomplete for generated files for Android (#2573 by Martin Bonnin ) [IDE Plugin] Fix npe in SqlDelightGotoDeclarationHandler (by Alexander Perfilyev ) [IDE Plugin] Mangle kotlin keywords in arguments inside insert stmt (#2433 by Alexander Perfilyev ) [IDE Plugin] Fix npe in SqlDelightFoldingBuilder (#2382 by Alexander Perfilyev ) [IDE Plugin] Catch ClassCastException in CopyPasteProcessor (#2369 by Alexander Perfilyev ) [IDE Plugin] Fix update live template (by Ilias Redissi ) [IDE Plugin] Adds descriptions to intention actions (#2489 by Alexander Perfilyev ) [IDE Plugin] Fix exception in CreateTriggerMixin if table is not found (by Alexander Perfilyev ) [Compiler] Topologically sort table creation statemenets [Compiler] Stop invoking forDatabaseFiles callback on directories (#2532) [Gradle Plugin] Propagate generateDatabaseInterface task dependency to potential consumers (#2518 by Martin Bonnin ) [1.5.1] - 2021-07-16 Added [PostgreSQL Dialect] PostgreSQL JSONB and ON Conflict Do Nothing (by Andrew Stewart ) [PostgreSQL Dialect] Adds support for PostgreSQL ON CONFLICT (column, ...) DO UPDATE (by Andrew Stewart ) [MySQL Dialect] Support MySQL generated columns (by Jeff Gulbronson ) [Native Driver] Add watchosX64 support [IDE Plugin] Add parameter types and annotations (by Alexander Perfilyev ) [IDE Plugin] Add action to generate 'select all' query (by Alexander Perfilyev ) [IDE Plugin] Show column types in autocomplete (by Alexander Perfilyev ) [IDE Plugin] Add icons to autocomplete (by Alexander Perfilyev ) [IDE Plugin] Add action to generate 'select by primary key' query (by Alexander Perfilyev ) [IDE Plugin] Add action to generate 'insert into' query (by Alexander Perfilyev ) [IDE Plugin] Add highlighting for column names, stmt identifiers, function names (by Alexander Perfilyev ) [IDE Plugin] Add remaining query generation actions (#489 by Alexander Perfilyev ) [IDE Plugin] Show parameter hints from insert-stmt (by Alexander Perfilyev ) [IDE Plugin] Table alias intention action (by Alexander Perfilyev ) [IDE Plugin] Qualify column name intention (by Alexander Perfilyev ) [IDE Plugin] Go to declaration for kotlin property (by Alexander Perfilyev ) Changed [Native Driver] Improve native transaction performance by avoiding freezing and shareable data structures when possible (by Anders Ha ) [Paging 3] Bump Paging3 version to 3.0.0 stable [JS Driver] Upgrade sql.js to 1.5.0 Fixed [JDBC SQLite Driver] Call close() on connection before clearing the ThreadLocal (#2444 by Hannes Stru\u00df ) [RX extensions] Fix subscription / disposal race leak (#2403 by Pierre Yves Ricau ) [Coroutines extension] Ensure we register query listener before notifying [Compiler] Sort notifyQueries to have consistent kotlin output file (by Jiayu Chen ) [Compiler] Don't annotate select query class properties with @JvmField (by Eliezer Graber ) [IDE Plugin] Fix import optimizer (#2350 by Alexander Perfilyev ) [IDE Plugin] Fix unused column inspection (by Alexander Perfilyev ) [IDE Plugin] Add nested classes support to import inspection and class annotator (by Alexander Perfilyev ) [IDE Plugin] Fix npe in CopyPasteProcessor (#2363 by Alexander Perfilyev ) [IDE Plugin] Fix crash in InlayParameterHintsProvider (#2359 by Alexander Perfilyev ) [IDE Plugin] Fix insertion of blank lines when copy-pasting any text into create table stmt (#2431 by Alexander Perfilyev ) [1.5.0] - 2021-04-23 Added [SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis ) [Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini ) [1.5.0] - 2021-04-23 Added [SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis ) [Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini ) [MySQL Dialect] Adds support for mysql's ON DUPLICATE KEY UPDATE conflict resolution. (by Ryan Harter ) [SQLite Dialect] Add compiler support for SQLite offsets() (by Quinton Roberts ) [IDE Plugin] Add import quick fix for unknown type (#683 by Alexander Perfilyev ) [IDE Plugin] Add unused import inspection (#1161 by Alexander Perfilyev ) [IDE Plugin] Add unused query inspection (by Alexander Perfilyev ) [IDE Plugin] Add unused column inspection (#569 by Alexander Perfilyev ) [IDE Plugin] Automatically bring imports on copy/paste (#684 by Alexander Perfilyev ) [IDE Plugin] Pop a balloon when there are incompatibilities between gradle/intellij plugin versions [IDE Plugin] Insert Into ... VALUES(?) parameter hints (#506 by Alexander Perfilyev ) [IDE Plugin] Inline parameter hints (by Alexander Perfilyev ) [Runtime] Include an API in the runtime for running migrations with callbacks (#1844) Changed [Compiler] Smart cast \"IS NOT NULL\" queries (#867) [Compiler] Protect against keywords that will fail at runtime (#1471, #1629) [Gradle Plugin] Reduce size of gradle plugin from 60mb -> 13mb. [Gradle Plugin] Properly support android variants, and remove support for KMM target-specific sql (#1039) [Gradle Plugin] Pick a minimum sqlite version based on minsdk (#1684) [Native Driver] Native driver connection pool and performance updates Fixed [Compiler] NBSP before lambdas (by Beno\u00eet Quenaudon ) [Compiler] Fix incompatible types in generated bind and cursor.get statements [Compiler] SQL clause should persist adapted type (#2067) [Compiler] Column with only NULL keyword should be nullable [Compiler] Dont generate mapper lambda with type annotations (#1957) [Compiler] If custom queries would clash, use the file name as an additional package suffix (#1057, #1278) [Compiler] Ensure foreign key cascades cause query listeners to be notified (#1325, #1485) [Compiler] If unioning two of the same type, return the table type (#1342) [Compiler] Ensure params to ifnull and coalesce can be nullable (#1263) [Compiler] Correctly use query-imposed nullability for expressions [MySQL Dialect] Support MySQL if statements [PostgreSQL Dialect] Retrieve NUMERIC and DECIMAL as Double in PostgreSQL (#2118) [SQLite Dialect] UPSERT notifications should account for BEFORE/AFTER UPDATE triggers. (#2198 by Anders Ha ) [SQLite Driver] Use multiple connections for threads in the SqliteDriver unless we are in memory (#1832) [JDBC Driver] JDBC Driver assumes autoCommit is true (#2041) [JDBC Driver] Ensure that we close connections on exception (#2306) [IDE Plugin] Fix GoToDeclaration/FindUsages being broken on Windows due to path separator bug (#2054 by Angus Holder ) [IDE Plugin] Ignore gradle errors instead of crashing in the IDE. [IDE Plugin] If a sqldelight file is moved to a non-sqldelight module, do not attempt codegen [IDE Plugin] Ignore codegen errors in IDE [IDE Plugin] Ensure that we dont try to negatively substring (#2068) [IDE Plugin] Also ensure project is not disposed before running gradle action (#2155) [IDE Plugin] Arithmetic on nullable types should also be nullable (#1853) [IDE Plugin] Make 'expand * intention' work with additional projections (#2173 by Alexander Perfilyev ) [IDE Plugin] If kotlin resolution fails during GoTo, dont attempt to go to sqldelight files [IDE Plugin] If IntelliJ encounters an exception while sqldelight is indexing, dont crash [IDE Plugin] Handle exceptions that happen while detecting errors before codegen in the IDE [IDE Plugin] Make the IDE plugin compatible with Dynamic Plugins (#1536) [Gradle Plugin] Race condition generating a database using WorkerApi (#2062 by St\u00e9phane Nicolas ) [Gradle Plugin] classLoaderIsolation prevents custom jdbc usage (#2048 by Ben Asher ) [Gradle Plugin] Improve missing packageName error message (by Niklas Baudy ) [Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998) [Gradle Plugin] Fix gradle build caching (#2075) [Gradle Plugin] Do not depend on kotlin-native-utils in Gradle plugin (by Ilya Matveev ) [Gradle Plugin] Also write the database if there are only migration files (#2094) [Gradle Plugin] Ensure diamond dependencies only get picked up once in the final compilation unit (#1455) Also just a general shoutout to Matthew Haughton who did a lot of work to improve the SQLDelight infrastructure this release. [1.4.4] - 2020-10-08 Added [PostgreSQL Dialect] Support data-modifying statements in WITH [PostgreSQL Dialect] Support substring function [Gradle Plugin] Added verifyMigrations flag for validating migrations during SQLDelight compilation (#1872) Changed [Compiler] Flag SQLite specific functions as unknown in non-SQLite dialects [Gradle Plugin] Provide a warning when the sqldelight plugin is applied but no databases are configured (#1421) Fixed [Compiler] Report an error when binding a column name in an ORDER BY clause (#1187 by Eliezer Graber ) [Compiler] Registry warnings appear when generating the db interface (#1792) [Compiler] Incorrect type inference for case statement (#1811) [Compiler] Provide better errors for migration files with no version (#2006) [Compiler] Required database type to marshal is incorrect for some database type ColumnAdapter's (#2012) [Compiler] Nullability of CAST (#1261) [Compiler] Lots of name shadowed warnings in query wrappers (#1946 by Eliezer Graber ) [Compiler] Generated code is using full qualifier names (#1939) [IDE Plugin] Trigger sqldelight code gen from gradle syncs [IDE Plugin] Plugin not regenerating database interface when changing .sq files (#1945) [IDE Plugin] Issue when moving files to new packages (#444) [IDE Plugin] If theres nowhere to move the cursor, do nothing instead of crashing (#1994) [IDE Plugin] Use empty package name for files outside of a gradle project (#1973) [IDE Plugin] Fail gracefully for invalid types (#1943) [IDE Plugin] Throw a better error message when encountering an unknown expression (#1958) [Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998) [Gradle Plugin] \"JavadocIntegrationKt not found\" compilation error when adding method doc in *.sq file (#1982) [Gradle Plugin] SqlDeslight gradle plugin doesn't support Configuration Caching (CoCa). (#1947 by St\u00e9phane Nicolas ) [SQLite JDBC Driver] SQLException: database in auto-commit mode (#1832) [Coroutines Extension] Fix IR backend for coroutines-extensions (#1918 by Derek Ellis ) [1.4.3] - 2020-09-04 Added [MySQL Dialect] Add support for MySQL last_insert_id function (by Kelvin Law ) [PostgreSQL Dialect] Support SERIAL data type (by Veyndan Stuart & Felipe Lima ) [PostgreSQL Dialect] Support PostgreSQL RETURNING (by Veyndan Stuart ) Fixed [MySQL Dialect] Treat MySQL AUTO_INCREMENT as having a default value (#1823) [Compiler] Fix Upsert statement compiler error (#1809 by Eliezer Graber ) [Compiler] Fix issue with invalid Kotlin being generated (#1925 by Eliezer Graber ) [Compiler] Have a better error message for unknown functions (#1843) [Compiler] Expose string as the type for the second parameter of instr [IDE Plugin] Fix daemon bloat and UI thread stalling for IDE plugin (#1916) [IDE Plugin] Handle null module scenario (#1902) [IDE Plugin] In unconfigured sq files return empty string for the package name (#1920) [IDE Plugin] Fix grouped statements and add an integration test for them (#1820) [IDE Plugin] Use built in ModuleUtil to find the module for an element (#1854) [IDE Plugin] Only add valid elements to lookups (#1909) [IDE Plugin] Parent can be null (#1857) [1.4.2] - 2020-08-27 Added [Runtime] Support new JS IR backend [Gradle Plugin] Add generateSqlDelightInterface Gradle task. (by Niklas Baudy ) [Gradle Plugin] Add verifySqlDelightMigration Gradle task. (by Niklas Baudy ) Fixed [IDE Plugin] Use the gradle tooling API to facilitate data sharing between the IDE and gradle [IDE Plugin] Default to false for schema derivation [IDE Plugin] Properly retrieve the commonMain source set [MySQL Dialect] Added minute to mySqlFunctionType() (by MaaxGr ) [1.4.1] - 2020-08-21 Added [Runtime] Support Kotlin 1.4.0 (#1859) Changed [Gradle Plugin] Make AGP dependency compileOnly (#1362) Fixed [Compiler] Add optional javadoc to column defintion rule and to table interface generator (#1224 by Daniel Eke ) [SQLite Dialect] Add support for sqlite fts5 auxiliary functions highlight, snippet, and bm25 (by Daniel Rampelt ) [MySQL Dialect] Support MySQL bit data type [MySQL Dialect] Support MySQL binary literals [PostgreSQL Dialect] Expose SERIAL from sql-psi (by Veyndan Stuart ) [PostgreSQL Dialect] Add BOOLEAN data type (by Veyndan Stuart ) [PostgreSQL Dialect] Add NULL column constraint (by Veyndan Stuart ) [HSQL Dialect] Adds AUTO_INCREMENT support to HSQL (by Ryan Harter ) [1.4.0] - 2020-06-22 Added [MySQL Dialect] MySQL support (by Jeff Gulbronson & Veyndan Stuart ) [PostgreSQL Dialect] Experimental PostgreSQL support (by Veyndan Stuart ) [HSQL Dialect] Experimental H2 support (by Marius Volkhart ) [SQLite Dialect] SQLite FTS5 support (by Ben Asher & James Palawaga ) [SQLite Dialect] Support alter table rename column (#1505 by Angus Holder ) [IDE] IDE support for migration (.sqm) files [IDE] Add SQLDelight Live Templates that mimic built-in SQL Live Templates (#1154 by Veyndan Stuart ) [IDE] Add new SqlDelight file action (#42 by Roman Zavarnitsyn ) [Runtime] transactionWithReturn API for transactions that return results [Compiler] Syntax for grouping multiple SQL statements together in a .sq file [Compiler] Support generating schemas from migration files [Gradle Plugin] Add a task for outputting migration files as valid sql Changed [Documentation] Overhaul of the documentation website (by Saket Narayan ) [Gradle Plugin] Improve unsupported dialect error message (by Veyndan Stuart ) [IDE] Dynamically change file icon based on dialect (by Veyndan Stuart ) [JDBC Driver] Expose a JdbcDriver constructor off of javax.sql.DataSource (#1614) Fixed [Compiler]Support Javadoc on tables and fix multiple javadoc in one file (#1224) [Compiler] Enable inserting a value for synthesized columns (#1351) [Compiler] Fix inconsistency in directory name sanitizing (by Zac Sweers ) [Compiler] Synthesized columns should retain nullability across joins (#1656) [Compiler] Pin the delete statement on the delete keyword (#1643) [Compiler] Fix quoting (#1525 by Angus Holder ) [Compiler] Fix the between operator to properly recurse into expressions (#1279) [Compiler] Give better error for missing table/column when creating an index (#1372) [Compiler] Enable using the outer querys projection in join constraints (#1346) [Native Driver] Make execute use transationPool (by Ben Asher ) [JDBC Driver] Use the jdbc transaction APIs instead of sqlite (#1693) [IDE] Fix virtualFile references to always be the original file (#1782) [IDE] Use the correct throwable when reporting errors to bugsnag (#1262) [Paging Extension] Fix leaky DataSource (#1628) [Gradle Plugin] If the output db file already exists when generating a schema, delete it (#1645) [Gradle Plugin] Fail migration validation if there are gaps [Gradle Plugin] Explicitely use the file index we set (#1644) [1.3.0] - 2020-04-03 New: [Gradle] Dialect property to specify with sql dialect to compile against. New: [Compiler] #1009 Experimental support of the mysql dialect. New: [Compiler] #1436 Support of sqlite:3.24 dialect and upsert. New: [JDBC Driver] Split out JDBC driver from sqlite jvm driver. Fix: [Compiler] #1199 Support lambdas of any length. Fix: [Compiler] #1610 Fix the return type of avg() to be nullable. Fix: [IntelliJ] #1594 Fix path separator handling which broke Goto and Find Usages on Windows. [1.2.2] - 2020-01-22 New: [Runtime] Support for Windows (mingW), tvOS, watchOS, and macOS architectures. Fix: [Compiler] Return type of sum() should be nullable. Fix: [Paging] Pass Transacter into QueryDataSourceFactory to avoid race conditions. Fix: [IntelliJ Plugin] Don't search through dependencies when looking for a file's package name. Fix: [Gradle] #862 Change validator logs in Gradle to debug level. Enhancement: [Gradle] Convert GenerateSchemaTask to use Gradle worker. Note: sqldelight-runtime artifact renamed to runtime. [1.2.1] - 2019-12-11 Fix: [Gradle] Kotlin Native 1.3.60 support. Fix: [Gradle] #1287 Warning when syncing. Fix: [Compiler] #1469 SynetheticAccessor creation for query. Fix: [JVM Driver] Fixed memory leak. NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript. [1.2.0] - 2019-08-30 New: [Runtime] Stable Flow api. Fix: [Gradle] Kotlin Native 1.3.50 support. Fix: [Gradle] #1380 Clean build sometimes fails. Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\". Fix: [Compile] #1405 Can't build project if query contains FTS table joined. Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules. [1.1.4] - 2019-07-11 New: [Runtime] Experimental kotlin Flow api. Fix: [Gradle] Kotlin/Native 1.3.40 compatibility. Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand. Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing. Fix: [Gradle] Allow gradle tasks to cache. Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl. Fix: [Compiler] Unique ids are generated for each query deterministically. Fix: [Compiler] Only notify listening queries when a transaction is complete. Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL. [1.1.3] - 2019-04-14 Gradle Metadata 1.0 release. [1.1.2] - 2019-04-14 New: [Runtime] #1267 Logging driver decorator. Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters. Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project. Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43. Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions. [1.1.1] - 2019-03-01 Fix: [Gradle] Fix module dependency compilation for android projects. Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate. Fix: [Compiler] Array types are properly printed. [1.1.0] - 2019-02-27 New: [Gradle] #502 Allow specifying schema module dependencies. Enhancement: [Compiler] #1111 Table errors are sorted before other errors. Fix: [Compiler] #1225 Return the correct type for REAL literals. Fix: [Compiler] #1218 docid propagates through triggers. [1.0.3] - 2019-01-30 Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32. Enhancement: [Runtime] #1190 Expose the mapper from the Query type. [1.0.2] - 2019-01-26 Fix: [Gradle Plugin] Update to kotlin 1.3.20. Fix: [Runtime] Transactions no longer swallow exceptions. [1.0.1] - 2019-01-21 Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration. Enhancement: [Compiler] #1173 Files without a package fail compilation. Fix: [IDE] Properly report IDE errors to Square. Fix: [IDE] #1162 Types in the same package show as error but work fine. Fix: [IDE] #1166 Renaming a table fails with NPE. Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT. [1.0.0] - 2019-01-08 New: Complete overhaul of generated code, now in kotlin. New: RxJava2 extensions artifact. New: Android Paging extensions artifact. New: Kotlin Multiplatform support. New: Android, iOS and JVM SQLite driver artifacts. New: Transaction API. [0.7.0] - 2018-02-12 New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings. New: Statement folding in the IDE. New: Boolean types are now automatically handled. Fix: Remove deprecated marshals from code generation. Fix: Correct 'avg' SQL function type mapping to be REAL. Fix: Correctly detect 'julianday' SQL function. [0.6.1] - 2017-03-22 New: Delete Update and Insert statements without arguments get compiled statements generated. Fix: Using clause within a view used in a subquery doesn't error. Fix: Duplicate types on generated Mapper removed. Fix: Subqueries can be used in expressions that check against arguments. [0.6.0] - 2017-03-06 New: Select queries are now exposed as a SqlDelightStatement factory instead of string constants. New: Query JavaDoc is now copied to statement and mapper factories. New: Emit string constants for view names. Fix: Queries on views which require factories now correctly require those factories are arguments. Fix: Validate the number of arguments to an insert matches the number of columns specified. Fix: Properly encode blob literals used in where clauses. Gradle 3.3 or newer is required for this release. [0.5.1] - 2016-10-24 New: Compiled statements extend an abstract type. Fix: Primitive types in parameters will be boxed if nullable. Fix: All required factories for bind args are present in factory method. Fix: Escaped column names are marshalled correctly. [0.5.0] - 2016-10-19 New: SQLite arguments can be passed typesafely through the Factory New: IntelliJ plugin performs formatting on .sq files New: Support for SQLite timestamp literals Fix: Parameterized types can be clicked through in IntelliJ Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor. Fix: Gradle plugin doesn't crash trying to print exceptions. [0.4.4] - 2016-07-20 New: Native support for shorts as column java type New: Javadoc on generated mappers and factory methods Fix: group_concat and nullif functions have proper nullability Fix: Compatibility with Android Studio 2.2-alpha Fix: WITH RECURSIVE no longer crashes plugin [0.4.3] - 2016-07-07 New: Compilation errors link to source file. New: Right-click to copy SQLDelight code as valid SQLite. New: Javadoc on named statements will appear on generated Strings. Fix: Generated view models include nullability annotations. Fix: Generated code from unions has proper type and nullability to support all possible columns. Fix: sum and round SQLite functions have proper type in generated code. Fix: CAST's, inner selects bugfixes. Fix: Autocomplete in CREATE TABLE statements. Fix: SQLite keywords can be used in packages. [0.4.2] - 2016-06-16 New: Marshal can be created from the factory. Fix: IntelliJ plugin generates factory methods with proper generic order. Fix: Function names can use any casing. [0.4.1] - 2016-06-14 Fix: IntelliJ plugin generates classes with proper generic order. Fix: Column definitions can use any casing. [0.4.0] - 2016-06-14 New: Mappers are generated per query instead of per table. New: Java types can be imported in .sq files. New: SQLite functions are validated. Fix: Remove duplicate errors. Fix: Uppercase column names and java keyword column names do not error. [0.3.2] - 2016-05-14 New: Autocompletion and find usages now work for views and aliases. Fix: Compile-time validation now allows functions to be used in selects. Fix: Support insert statements which only declare default values. Fix: Plugin no longer crashes when a project not using SQLDelight is imported. [0.3.1] - 2016-04-27 Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references. Fix: Subexpressions are evaluated properly. [0.3.0] - 2016-04-26 New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type. New: Bug reports can be sent from the IDE. Fix: Autocomplete functions properly. Fix: SQLDelight model files update on .sq file edit. Removed: Attached databases no longer supported. [0.2.2] - 2016-03-07 New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements. Fix: Don't crash IDE plugin on file move/create. [0.2.1] - 2016-03-07 New: Ctrl+ / (Cmd+ / on OSX) toggles comment of the selected line(s). New: Compile-time validation of the columns used by SQL queries. Fix: Support Windows paths in both the IDE and Gradle plugin. [0.2.0] - 2016-02-29 New: Added copy constructor to Marshal class. New: Update to Kotlin 1.0 final. Fix: Report 'sqldelight' folder structure problems in a non-failing way. Fix: Forbid columns named table_name . Their generated constant clashes with the table name constant. Fix: Ensure IDE plugin generates model classes immediately and regardless of whether .sq files were opened. Fix: Support Windows paths in both the IDE and Gradle plugin. [0.1.2] - 2016-02-13 Fix: Remove code which prevented the Gradle plugin from being used in most projects. Fix: Add missing compiler dependency on the Antlr runtime. [0.1.1] - 2016-02-12 Fix: Ensure the Gradle plugin points to the same version of the runtime as itself. [0.1.0] - 2016-02-12 Initial release.","title":"Changelog"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#200-alpha04-2022-10-03","text":"","title":"[2.0.0-alpha04] - 2022-10-03"},{"location":"changelog/#breaking-changes","text":"The Paging 3 extension API has changed to only allow int types for the count. The coroutines extension now requires a dispatcher to be passed in instead of defaulting. Dialect and Driver classes are final, use delegation instead.","title":"Breaking Changes"},{"location":"changelog/#added","text":"[HSQL Dialect] Hsql: Support using DEFAULT for generated columns in Insert (#3372 by Philip Wedemann ) [PostgreSQL Dialect] PostgreSQL: Support using DEFAULT for generated columns in INSERT (#3373 by Philip Wedemann ) [PostgreSQL Dialect] Add NOW() to PostgreSQL (#3403 by Philip Wedemann ) [PostgreSQL Dialect] PostgreSQL Add NOT operator (#3504 by Philip Wedemann ) [Paging] Allow passing in CoroutineContext to *QueryPagingSource (#3384) [Gradle Plugin] Add better version catalog support for dialects (#3435) [Native Driver] Add callback to hook into DatabaseConfiguration creation of NativeSqliteDriver (#3512 by Sven Jacobs )","title":"Added"},{"location":"changelog/#changed","text":"[Paging] Add a default dispatcher to the KeyedQueryPagingSource backed QueryPagingSource function (#3385) [Paging] Make OffsetQueryPagingSource only work with Int (#3386) [Async Runtime] Move await* to upper class ExecutableQuery (#3524 by Philip Wedemann ) [Coroutines Extensions] Remove default params to flow extensions (#3489)","title":"Changed"},{"location":"changelog/#fixed","text":"[Gradle Plugin] Update to Kotlin 1.7.20 (#3542 by Zac Sweers ) [R2DBC Driver] Adopt R2DBC changes which do not always send a value (#3525 by Philip Wedemann ) [HSQL Dialect] Fix failing sqlite VerifyMigrationTask with Hsql (#3380 by Philip Wedemann ) [Gradle Plugin] Convert tasks to use lazy configuration API (by Matthew Haughton ) [Gradle Plugin] Avoid NPEs in Kotlin 1.7.20 (#3398 by Zac Sweers ) [Gradle Plugin] Fix description of squash migrations task (#3449) [IDE Plugin] Fix NoSuchFieldError in newer Kotlin plugins (#3422 by Madis Pink ) [IDE Plugin] IDEA: UnusedQueryInspection - fix ArrayIndexOutOfBoundsException. (#3427 by Niklas Baudy ) [IDE Plugin] Use reflection for old kotlin plugin references [Compiler] Custom dialect with extension function don't create imports (#3338 by Philip Wedemann ) [Compiler] Fix escaping CodeBlock.of(\"${CodeBlock.toString()}\") (#3340 by Philip Wedemann ) [Compiler] Await async execute statements in migrations (#3352) [Compiler] Fix AS (#3370 by Philip Wedemann ) [Compiler] getObject method supports automatic filling of the actual type. (#3401 by Rob X ) [Compiler] Fix codegen for async grouped returning statements (#3411) [Compiler] Infer the Kotlin type of bind parameter, if possible, or fail with a better error message (#3413 by Philip Wedemann ) [Compiler] Don't allow ABS(\"foo\") (#3430 by Philip Wedemann ) [Compiler] Support inferring kotlin type from other parameters (#3431 by Philip Wedemann ) [Compiler] Always create the database implementation (#3540 by Philip Wedemann ) [Compiler] Relax javaDoc and add it to custom mapper function too (#3554 Philip Wedemann ) [Compiler] Fix DEFAULT in binding (by Philip Wedemann ) [Paging] Fix Paging 3 (#3396) [Paging] Allow construction of OffsetQueryPagingSource with Long (#3409) [Paging] Don't statically swap Dispatchers.Main (#3428)","title":"Fixed"},{"location":"changelog/#200-alpha03-2022-06-17","text":"","title":"[2.0.0-alpha03] - 2022-06-17"},{"location":"changelog/#breaking-changes_1","text":"Dialects are now references like actual gradle dependencies. sqldelight { MyDatabase { dialect ( \"app.cash.sqldelight:postgres-dialect:2.0.0-alpha03\" ) } } The AfterVersionWithDriver type was removed in favour of AfterVersion which now always has the driver. The Schema type is no longer a subtype of SqlDriver PreparedStatement APIs are now called with zero-based indexes.","title":"Breaking Changes"},{"location":"changelog/#added_1","text":"[IDE Plugin] Added support for running SQLite, MySQL, and PostgreSQL commands against a running database (#2718 by Alexander Perfilyev ) [IDE Plugin] Add support for the android studio DB inspector (#3107 by Alexander Perfilyev ) [Runtime] Add support for async drivers (#3168 by Derek Ellis ) [Native Driver] Support new kotlin native memory model (#3177 by Kevin Galligan ) [JS Driver] Add a driver for SqlJs workers (#3203 by Derek Ellis ) [Gradle Plugin] Expose the classpath for SQLDelight tasks [Gradle Plugin] Add a gradle task for squashing migrations [Gradle Plugin] Add a flag to ignore schema definitions during migration checks [MySQL Dialect] Support FOR SHARE and FOR UPDATE in MySQL (#3098) [MySQL Dialect] Support MySQL index hints (#3099) [PostgreSQL Dialect] Add date_trunc (#3295 by Philip Wedemann ) [JSON Extensions] Support JSON table functions (#3090)","title":"Added"},{"location":"changelog/#changed_1","text":"[Runtime] Remove the AfterVersion type without the driver (#3091) [Runtime] Move Schema type to top-level [Runtime] Open dialect and resolver to support 3rd party implementations (#3232 by Philip Wedemann ) [Compiler] Include the dialect used to compile in failure reports (#3086) [Compiler] Skip unused adapters (#3162 by Eliezer Graber ) [Compiler] Use zero based index in PrepareStatement (#3269 by Philip Wedemann ) [Gradle Plugin] Also make the dialect a proper gradle dependency instead of a string (#3085) [Gradle Plugin] Gradle Verify Task: Throw when missing database file. (#3126 by Niklas Baudy )","title":"Changed"},{"location":"changelog/#fixed_1","text":"[Gradle Plugin] Minor cleanups and tweaks to the Gradle plugin (#3171 by Matthew Haughton ) [Gradle Plugin] Dont use an AGP string for the generated directory [Gradle Plugin] Use AGP namespace attribute (#3220) [Gradle Plugin] Do not add kotlin-stdlib as a runtime dependency of the Gradle plugin (#3245 by [Martin Bonnin][mbonnin]) [Gradle Plugin] Simplify the multiplatform configuration (#3246 by [Martin Bonnin][mbonnin]) [Gradle Plugin] Support js only projects (#3310 by Philip Wedemann ) [IDE Plugin] Use java home for gradle tooling API (#3078) [IDE Plugin] Load the JDBC driver on the correct classLoader inside the IDE plugin (#3080) [IDE Plugin] Mark the file element as null before invalidating to avoid errors during already existing PSI changes (#3082) [IDE Plugin] Dont crash finding usages of the new table name in an ALTER TABLE statement (#3106) [IDE Plugin] Optimize the inspectors and enable them to fail silently for expected exception types (#3121) [IDE Plugin] Delete files that should be generated directories (#3198) [IDE Plugin] Fix a not-safe operator call [Compiler] Ensure updates and deletes with RETURNING statements execute queries. (#3084) [Compiler] Correctly infer argument types in compound selects (#3096) [Compiler] Common tables do not generate data classes so dont return them (#3097) [Compiler] Find the top migration file faster (#3108) [Compiler] Properly inherit nullability on the pipe operator [Compiler] Support the iif ANSI SQL function [Compiler] Don't generate empty query files (#3300 by Philip Wedemann ) [Compiler] Fix adapter with question mark only (#3314 by Philip Wedemann ) [PostgreSQL Dialect] Postgres primary key columns are always non-null (#3092) [PostgreSQL Dialect] Fix copy with same name in multiple tables (#3297 by Philip Wedemann ) [SQLite 3.35 Dialect] Only show an error when dropping an indexed column from the altered table (#3158 by Eliezer Graber )","title":"Fixed"},{"location":"changelog/#200-alpha02-2022-04-13","text":"","title":"[2.0.0-alpha02] - 2022-04-13"},{"location":"changelog/#breaking-changes_2","text":"You'll need to replace all occurrences of app.cash.sqldelight.runtime.rx with app.cash.sqldelight.rx2","title":"Breaking Changes"},{"location":"changelog/#added_2","text":"[Compiler] Support returning at the end of a grouped statement [Compiler] Support compiler extensions via dialect modules and add a SQLite JSON extension (#1379, #2087) [Compiler] Support PRAGMA statements which return a value (#1106) [Compiler] Support generating value types for marked columns [Compiler] Add support for optimistic locks and validation (#1952) [Compiler] Support multi-update statements [PostgreSQL] Support postgres returning statements [PostgreSQL] Support postgres date types [PostgreSQL] Support pg intervals [PostgreSQL] Support PG Booleans and fix inserts on alter tables [PostgreSQL] Support optional limits in Postgres [PostgreSQL] Support PG BYTEA type [PostgreSQL] Add a test for postgres serials [PostgreSQL] Support for update postgres syntax [PostgreSQL] Support PostgreSQL array types [PostgreSQL] Properly store/retrieve UUID types in PG [PostgreSQL] Support PostgreSQL NUMERIC type (#1882) [PostgreSQL] Support returning queries inside of common table expressions (#2471) [PostgreSQL] Support json specific operators [PostgreSQL] Add Postgres Copy (by Philip Wedemann ) [MySQL] Support MySQL Replace [MySQL] Support NUMERIC/BigDecimal MySQL types (#2051) [MySQL] Support MySQL truncate statement [MySQL] Support json specific operators in Mysql (by Eliezer Graber ) [MySQL] Support MySql INTERVAL (#2969 by Eliezer Graber ) [HSQL] Add HSQL Window functionality [SQLite] Don't replace equality checks for nullable parameters in a WHERE (#1490 by Eliezer Graber ) [SQLite] Support Sqlite 3.35 returning statements (#1490 by Eliezer Graber ) [SQLite] Support GENERATED clause [SQLite] Add support for Sqlite 3.38 dialect (by Eliezer Graber )","title":"Added"},{"location":"changelog/#changed_2","text":"[Compiler] Clean up generated code a bit [Compiler] Forbid usage of table parameters in grouped statements (#1822) [Compiler] Put grouped queries inside a transaction (#2785) [Runtime] Return the updated row count from the drivers execute method [Runtime] Confine SqlCursor to the critical section accessing the connection. (#2123 by Anders Ha ) [Gradle Plugin] Compare schema definitions for migrations (#841) [PostgreSQL] Disallow double quotes for PG [MySQL] Error on usage of == in MySQL (#2673)","title":"Changed"},{"location":"changelog/#fixed_2","text":"[Compiler] Same adapter type from different tables causing a compilation error in 2.0 alpha [Compiler] Problem compiling upsert statement (#2791) [Compiler] Query result should use tables in the select if there are multiple matches (#1874, #2313) [Compiler] Support updating a view which has a INSTEAD OF trigger (#1018) [Compiler] Support from and for in function names [Compiler] Allow SEPARATOR keyword in function expressions [Compiler] Cannot access ROWID of aliased table in ORDER BY [Compiler] Aliased column name is not recognized in HAVING clause in MySQL [Compiler] Erroneous 'Multiple columns found' error [Compiler] Unable to set PRAGMA locking_mode = EXCLUSIVE; [PostgreSQL] Postgresql rename column [MySQL] UNIX_TIMESTAMP, TO_SECONDS, JSON_ARRAYAGG MySQL functions not recognized [SQLite] fix SQLite window functionality [IDE Plugin] Run the goto handler in an empty progress indicator (#2990) [IDE Plugin] Ensure the highlight visitor doesnt run if the project isnt configured (#2981, #2976) [IDE Plugin] Ensure transitive generated code is also updated in the IDE (#1837) [IDE Plugin] Invalidate indexes when updating the dialect","title":"Fixed"},{"location":"changelog/#200-alpha01-2022-03-31","text":"This is the first alpha release for 2.0 and has some breaking changes. We expect more ABI breaking changes to come so don't publish any libraries with dependencies on this release (applications should be fine).","title":"[2.0.0-alpha01] - 2022-03-31"},{"location":"changelog/#breaking-changes_3","text":"First, you'll need to replace all occurrences of com.squareup.sqldelight with app.cash.sqldelight Second, you'll need to replace all occurrences of app.cash.sqldelight.android with app.cash.sqldelight.driver.android Third, you'll need to replace all occurrences of app.cash.sqldelight.sqlite.driver with app.cash.sqldelight.driver.jdbc.sqlite Fourth, you'll need to replace all occurrences of app.cash.sqldelight.drivers.native with app.cash.sqldelight.driver.native The IDE plugin must be updated to a 2.X version, which can be found in the alpha or eap channel Dialects are now dependencies which you can specify within gradle: sqldelight { MyDatabase { packageName = \"com.example\" dialect = \"app.cash.sqldelight:mysql-dialect:2.0.0-alpha01\" } } The currently supported dialects are mysql-dialect , postgresql-dialect , hsql-dialect , sqlite-3-18-dialect , sqlite-3-24-dialect , sqlite-3-25-dialect , sqlite-3-30-dialect , and sqlite-3-35-dialect Primitive types must now be imported (for example INTEGER AS Boolean you have to import kotlin.Boolean ), some previously supported types now need an adapter. Primitive adapters are available in app.cash.sqldelight:primitive-adapters:2.0.0-alpha01 for most conversions (like IntColumnAdapter for doing Integer AS kotlin.Int ).","title":"Breaking Changes"},{"location":"changelog/#added_3","text":"[IDE Plugin] Basic suggested migration (by Alexander Perfilyev ) [IDE Plugin] Add import hint action (by Alexander Perfilyev ) [IDE Plugin] Add kotlin class completion (by Alexander Perfilyev ) [Gradle Plugin] Add shortcut for Gradle type safe project accessors (by Philip Wedemann ) [Compiler] Customize codegen based on dialect (by Marius Volkhart ) [JDBC Driver] Add common types to JdbcDriver (by Marius Volkhart ) [SQLite] Add support for the sqlite 3.35 (by Eliezer Graber ) [SQLite] Add support for ALTER TABLE DROP COLUMN (by Eliezer Graber ) [SQLite] Add support for Sqlite 3.30 dialect (by Eliezer Graber ) [SQLite] Support NULLS FIRST/LAST in sqlite (by Eliezer Graber ) [HSQL] Add HSQL support for generated clause (by Marius Volkhart ) [HSQL] Add support for named parameters in HSQL (by Marius Volkhart ) [HSQL] Customize the HSQL insert query (by Marius Volkhart )","title":"Added"},{"location":"changelog/#changed_3","text":"[Everything] Package name has changed from com.squareup.sqldelight to app.cash.sqldelight. [Runtime] Move dialects into their own isolated gradle modules [Runtime] Switch to driver-implemented query notifications. [Runtime] Extract default column adapters to separate module (#2056, #2060) [Compiler] Let modules generate the queries implementations instead of redoing it in each module [Compiler] Remove the custom toString generation of generated data classes. (by Paul Woitaschek ) [JS Driver] Remove sql.js dependency from sqljs-driver (by Derek Ellis ) [Paging] Remove the android paging 2 extension [IDE Plugin] Add an editor banner while SQLDelight is syncing (#2511) [IDE Plugin] Minimum supported IntelliJ version is 2021.1","title":"Changed"},{"location":"changelog/#fixed_3","text":"[Runtime] Flatten listener list to reduce allocations and pointer chasing. (by Anders Ha ) [IDE Plugin] Fix error message to allow jumping to error (by Philip Wedemann ) [IDE Plugin] Add missing inspection descriptions (#2768 by Alexander Perfilyev ) [IDE Plugin] Fix exception in GotoDeclarationHandler (#2531, #2688, #2804 by Alexander Perfilyev ) [IDE Plugin] Highlight import keyword (by Alexander Perfilyev ) [IDE Plugin] Fix unresolved kotlin types (#1678 by Alexander Perfilyev ) [IDE Plugin] Fix highlighting for unresolved package (#2543 by Alexander Perfilyev ) [IDE Plugin] Dont attempt to inspect mismatched columns if the project index is not yet initialized [IDE Plugin] Dont initialize the file index until a gradle sync has occurred [IDE Plugin] Cancel the SQLDelight import if a gradle sync begins [IDE Plugin] Regenerate the database outside of the thread an undo action is performed on [IDE Plugin] If a reference cannot be resolves use a blank java type [IDE Plugin] Correctly move off the main thread during file parsing and only move back on to write [IDE Plugin] Improve compatibility with older IntelliJ versions (by Matthew Haughton ) [IDE Plugin] Use faster annotation API [Gradle Plugin] Explicitly support js/android plugins when adding runtime (by Zac Sweers ) [Gradle Plugin] Register migration output task without derviving schemas from migrations (#2744 by Kevin Cianfarini ) [Gradle Plugin] If the migration task crashes, print the file it crashed running [Gradle Plugin] Sort files when generating code to ensure idempotent outputs (by Zac Sweers ) [Compiler] Use faster APIs for iterating files and dont explore the entire PSI graph [Compiler] Add keyword mangling to select function parameters (#2759 by Alexander Perfilyev ) [Compiler] Fix packageName for migration adapter (by Philip Wedemann ) [Compiler] Emit annotations on properties instead of types (#2798 by Alexander Perfilyev ) [Compiler] Sort arguments before passing to a Query subtype (#2379 by Alexander Perfilyev )","title":"Fixed"},{"location":"changelog/#153-2021-11-23","text":"","title":"[1.5.3] - 2021-11-23"},{"location":"changelog/#added_4","text":"[JDBC Driver] Open JdbcDriver for 3rd party driver implementations (#2672 by Philip Wedemann ) [MySQL Dialect] Add missing functions for time increments (#2671 by Sam Doward ) [Coroutines Extension] Add M1 targets for coroutines-extensions (by Philip Dukhov )","title":"Added"},{"location":"changelog/#changed_4","text":"[Paging3 Extension] Distribute sqldelight-android-paging3 as JAR instead of AAR (#2634 by Marco Romano ) Property names which are also soft keywords will now be suffixed with underscores. For instance value will be exposed as value_","title":"Changed"},{"location":"changelog/#fixed_4","text":"[Compiler] Don't extract variables for duplicate array parameters (by Alexander Perfilyev ) [Gradle Plugin] add kotlin.mpp.enableCompatibilityMetadataVariant. (#2628 by Martin Bonnin ) [IDE Plugin] Find usages processing requires a read action","title":"Fixed"},{"location":"changelog/#152-2021-10-12","text":"","title":"[1.5.2] - 2021-10-12"},{"location":"changelog/#added_5","text":"[Gradle Plugin] HMPP support (#2548 by Martin Bonnin ) [IDE Plugin] Add NULL comparison inspection (by Alexander Perfilyev ) [IDE Plugin] Add inspection suppressor (#2519 by Alexander Perfilyev ) [IDE Plugin] Mixed named and positional parameters inspection (by Alexander Perfilyev ) [SQLite Driver] Add mingwX86 target. (#2558 by Nikita Kozhemyakin ) [SQLite Driver] Add M1 targets [SQLite Driver] Add linuxX64 support (#2456 by Cedric Hippmann ) [MySQL Dialect] Add ROW_COUNT function to mysql (#2523) [PostgreSQL Dialect] postgres rename, drop column (by Juan Liska ) [PostgreSQL Dialect] PostgreSQL grammar doesn't recognize CITEXT [PostgreSQL Dialect] Include TIMESTAMP WITH TIME ZONE and TIMESTAMPTZ [PostgreSQL Dialect] Add grammar for PostgreSQL GENERATED columns [Runtime] Provide SqlDriver as a parameter to AfterVersion (#2534, 2614 by Ahmed El-Helw )","title":"Added"},{"location":"changelog/#changed_5","text":"[Gradle Plugin] explicitely require Gradle 7.0 (#2572 by Martin Bonnin ) [Gradle Plugin] Make VerifyMigrationTask support Gradle's up-to-date checks (#2533 by Matthew Haughton ) [IDE Plugin] Don't warn with \"Join compares two columns of different types\" when joining nullable with non-nullable type (#2550 by Piotr Chmielowski ) [IDE Plugin] Clarify the error for the lowercase 'as' in column type (by Alexander Perfilyev )","title":"Changed"},{"location":"changelog/#fixed_5","text":"[IDE Plugin] Do not reparse under a new dialect if the project is already disposed (#2609) [IDE Plugin] If the associated virtual file is null, the module is null (#2607) [IDE Plugin] Avoid crashing during the unused query inspection (#2610) [IDE Plugin] Run the database sync write inside of a write action (#2605) [IDE Plugin] Let the IDE schedule SQLDelight syncronization [IDE Plugin] Fix npe in JavaTypeMixin (#2603 by Alexander Perfilyev ) [IDE Plugin] Fix IndexOutOfBoundsException in MismatchJoinColumnInspection (#2602 by Alexander Perfilyev ) [IDE Plugin] Add description for UnusedColumnInspection (#2600 by Alexander Perfilyev ) [IDE Plugin] Wrap PsiElement.generatedVirtualFiles into read action (#2599 by Alexander Perfilyev ) [IDE Plugin] Remove unnecessary nonnull cast (#2596) [IDE Plugin] Properly handle nulls for find usages (#2595) [IDE Plugin] Fix IDE autocomplete for generated files for Android (#2573 by Martin Bonnin ) [IDE Plugin] Fix npe in SqlDelightGotoDeclarationHandler (by Alexander Perfilyev ) [IDE Plugin] Mangle kotlin keywords in arguments inside insert stmt (#2433 by Alexander Perfilyev ) [IDE Plugin] Fix npe in SqlDelightFoldingBuilder (#2382 by Alexander Perfilyev ) [IDE Plugin] Catch ClassCastException in CopyPasteProcessor (#2369 by Alexander Perfilyev ) [IDE Plugin] Fix update live template (by Ilias Redissi ) [IDE Plugin] Adds descriptions to intention actions (#2489 by Alexander Perfilyev ) [IDE Plugin] Fix exception in CreateTriggerMixin if table is not found (by Alexander Perfilyev ) [Compiler] Topologically sort table creation statemenets [Compiler] Stop invoking forDatabaseFiles callback on directories (#2532) [Gradle Plugin] Propagate generateDatabaseInterface task dependency to potential consumers (#2518 by Martin Bonnin )","title":"Fixed"},{"location":"changelog/#151-2021-07-16","text":"","title":"[1.5.1] - 2021-07-16"},{"location":"changelog/#added_6","text":"[PostgreSQL Dialect] PostgreSQL JSONB and ON Conflict Do Nothing (by Andrew Stewart ) [PostgreSQL Dialect] Adds support for PostgreSQL ON CONFLICT (column, ...) DO UPDATE (by Andrew Stewart ) [MySQL Dialect] Support MySQL generated columns (by Jeff Gulbronson ) [Native Driver] Add watchosX64 support [IDE Plugin] Add parameter types and annotations (by Alexander Perfilyev ) [IDE Plugin] Add action to generate 'select all' query (by Alexander Perfilyev ) [IDE Plugin] Show column types in autocomplete (by Alexander Perfilyev ) [IDE Plugin] Add icons to autocomplete (by Alexander Perfilyev ) [IDE Plugin] Add action to generate 'select by primary key' query (by Alexander Perfilyev ) [IDE Plugin] Add action to generate 'insert into' query (by Alexander Perfilyev ) [IDE Plugin] Add highlighting for column names, stmt identifiers, function names (by Alexander Perfilyev ) [IDE Plugin] Add remaining query generation actions (#489 by Alexander Perfilyev ) [IDE Plugin] Show parameter hints from insert-stmt (by Alexander Perfilyev ) [IDE Plugin] Table alias intention action (by Alexander Perfilyev ) [IDE Plugin] Qualify column name intention (by Alexander Perfilyev ) [IDE Plugin] Go to declaration for kotlin property (by Alexander Perfilyev )","title":"Added"},{"location":"changelog/#changed_6","text":"[Native Driver] Improve native transaction performance by avoiding freezing and shareable data structures when possible (by Anders Ha ) [Paging 3] Bump Paging3 version to 3.0.0 stable [JS Driver] Upgrade sql.js to 1.5.0","title":"Changed"},{"location":"changelog/#fixed_6","text":"[JDBC SQLite Driver] Call close() on connection before clearing the ThreadLocal (#2444 by Hannes Stru\u00df ) [RX extensions] Fix subscription / disposal race leak (#2403 by Pierre Yves Ricau ) [Coroutines extension] Ensure we register query listener before notifying [Compiler] Sort notifyQueries to have consistent kotlin output file (by Jiayu Chen ) [Compiler] Don't annotate select query class properties with @JvmField (by Eliezer Graber ) [IDE Plugin] Fix import optimizer (#2350 by Alexander Perfilyev ) [IDE Plugin] Fix unused column inspection (by Alexander Perfilyev ) [IDE Plugin] Add nested classes support to import inspection and class annotator (by Alexander Perfilyev ) [IDE Plugin] Fix npe in CopyPasteProcessor (#2363 by Alexander Perfilyev ) [IDE Plugin] Fix crash in InlayParameterHintsProvider (#2359 by Alexander Perfilyev ) [IDE Plugin] Fix insertion of blank lines when copy-pasting any text into create table stmt (#2431 by Alexander Perfilyev )","title":"Fixed"},{"location":"changelog/#150-2021-04-23","text":"","title":"[1.5.0] - 2021-04-23"},{"location":"changelog/#added_7","text":"[SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis ) [Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini )","title":"Added"},{"location":"changelog/#150-2021-04-23_1","text":"","title":"[1.5.0] - 2021-04-23"},{"location":"changelog/#added_8","text":"[SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis ) [Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini ) [MySQL Dialect] Adds support for mysql's ON DUPLICATE KEY UPDATE conflict resolution. (by Ryan Harter ) [SQLite Dialect] Add compiler support for SQLite offsets() (by Quinton Roberts ) [IDE Plugin] Add import quick fix for unknown type (#683 by Alexander Perfilyev ) [IDE Plugin] Add unused import inspection (#1161 by Alexander Perfilyev ) [IDE Plugin] Add unused query inspection (by Alexander Perfilyev ) [IDE Plugin] Add unused column inspection (#569 by Alexander Perfilyev ) [IDE Plugin] Automatically bring imports on copy/paste (#684 by Alexander Perfilyev ) [IDE Plugin] Pop a balloon when there are incompatibilities between gradle/intellij plugin versions [IDE Plugin] Insert Into ... VALUES(?) parameter hints (#506 by Alexander Perfilyev ) [IDE Plugin] Inline parameter hints (by Alexander Perfilyev ) [Runtime] Include an API in the runtime for running migrations with callbacks (#1844)","title":"Added"},{"location":"changelog/#changed_7","text":"[Compiler] Smart cast \"IS NOT NULL\" queries (#867) [Compiler] Protect against keywords that will fail at runtime (#1471, #1629) [Gradle Plugin] Reduce size of gradle plugin from 60mb -> 13mb. [Gradle Plugin] Properly support android variants, and remove support for KMM target-specific sql (#1039) [Gradle Plugin] Pick a minimum sqlite version based on minsdk (#1684) [Native Driver] Native driver connection pool and performance updates","title":"Changed"},{"location":"changelog/#fixed_7","text":"[Compiler] NBSP before lambdas (by Beno\u00eet Quenaudon ) [Compiler] Fix incompatible types in generated bind and cursor.get statements [Compiler] SQL clause should persist adapted type (#2067) [Compiler] Column with only NULL keyword should be nullable [Compiler] Dont generate mapper lambda with type annotations (#1957) [Compiler] If custom queries would clash, use the file name as an additional package suffix (#1057, #1278) [Compiler] Ensure foreign key cascades cause query listeners to be notified (#1325, #1485) [Compiler] If unioning two of the same type, return the table type (#1342) [Compiler] Ensure params to ifnull and coalesce can be nullable (#1263) [Compiler] Correctly use query-imposed nullability for expressions [MySQL Dialect] Support MySQL if statements [PostgreSQL Dialect] Retrieve NUMERIC and DECIMAL as Double in PostgreSQL (#2118) [SQLite Dialect] UPSERT notifications should account for BEFORE/AFTER UPDATE triggers. (#2198 by Anders Ha ) [SQLite Driver] Use multiple connections for threads in the SqliteDriver unless we are in memory (#1832) [JDBC Driver] JDBC Driver assumes autoCommit is true (#2041) [JDBC Driver] Ensure that we close connections on exception (#2306) [IDE Plugin] Fix GoToDeclaration/FindUsages being broken on Windows due to path separator bug (#2054 by Angus Holder ) [IDE Plugin] Ignore gradle errors instead of crashing in the IDE. [IDE Plugin] If a sqldelight file is moved to a non-sqldelight module, do not attempt codegen [IDE Plugin] Ignore codegen errors in IDE [IDE Plugin] Ensure that we dont try to negatively substring (#2068) [IDE Plugin] Also ensure project is not disposed before running gradle action (#2155) [IDE Plugin] Arithmetic on nullable types should also be nullable (#1853) [IDE Plugin] Make 'expand * intention' work with additional projections (#2173 by Alexander Perfilyev ) [IDE Plugin] If kotlin resolution fails during GoTo, dont attempt to go to sqldelight files [IDE Plugin] If IntelliJ encounters an exception while sqldelight is indexing, dont crash [IDE Plugin] Handle exceptions that happen while detecting errors before codegen in the IDE [IDE Plugin] Make the IDE plugin compatible with Dynamic Plugins (#1536) [Gradle Plugin] Race condition generating a database using WorkerApi (#2062 by St\u00e9phane Nicolas ) [Gradle Plugin] classLoaderIsolation prevents custom jdbc usage (#2048 by Ben Asher ) [Gradle Plugin] Improve missing packageName error message (by Niklas Baudy ) [Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998) [Gradle Plugin] Fix gradle build caching (#2075) [Gradle Plugin] Do not depend on kotlin-native-utils in Gradle plugin (by Ilya Matveev ) [Gradle Plugin] Also write the database if there are only migration files (#2094) [Gradle Plugin] Ensure diamond dependencies only get picked up once in the final compilation unit (#1455) Also just a general shoutout to Matthew Haughton who did a lot of work to improve the SQLDelight infrastructure this release.","title":"Fixed"},{"location":"changelog/#144-2020-10-08","text":"","title":"[1.4.4] - 2020-10-08"},{"location":"changelog/#added_9","text":"[PostgreSQL Dialect] Support data-modifying statements in WITH [PostgreSQL Dialect] Support substring function [Gradle Plugin] Added verifyMigrations flag for validating migrations during SQLDelight compilation (#1872)","title":"Added"},{"location":"changelog/#changed_8","text":"[Compiler] Flag SQLite specific functions as unknown in non-SQLite dialects [Gradle Plugin] Provide a warning when the sqldelight plugin is applied but no databases are configured (#1421)","title":"Changed"},{"location":"changelog/#fixed_8","text":"[Compiler] Report an error when binding a column name in an ORDER BY clause (#1187 by Eliezer Graber ) [Compiler] Registry warnings appear when generating the db interface (#1792) [Compiler] Incorrect type inference for case statement (#1811) [Compiler] Provide better errors for migration files with no version (#2006) [Compiler] Required database type to marshal is incorrect for some database type ColumnAdapter's (#2012) [Compiler] Nullability of CAST (#1261) [Compiler] Lots of name shadowed warnings in query wrappers (#1946 by Eliezer Graber ) [Compiler] Generated code is using full qualifier names (#1939) [IDE Plugin] Trigger sqldelight code gen from gradle syncs [IDE Plugin] Plugin not regenerating database interface when changing .sq files (#1945) [IDE Plugin] Issue when moving files to new packages (#444) [IDE Plugin] If theres nowhere to move the cursor, do nothing instead of crashing (#1994) [IDE Plugin] Use empty package name for files outside of a gradle project (#1973) [IDE Plugin] Fail gracefully for invalid types (#1943) [IDE Plugin] Throw a better error message when encountering an unknown expression (#1958) [Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998) [Gradle Plugin] \"JavadocIntegrationKt not found\" compilation error when adding method doc in *.sq file (#1982) [Gradle Plugin] SqlDeslight gradle plugin doesn't support Configuration Caching (CoCa). (#1947 by St\u00e9phane Nicolas ) [SQLite JDBC Driver] SQLException: database in auto-commit mode (#1832) [Coroutines Extension] Fix IR backend for coroutines-extensions (#1918 by Derek Ellis )","title":"Fixed"},{"location":"changelog/#143-2020-09-04","text":"","title":"[1.4.3] - 2020-09-04"},{"location":"changelog/#added_10","text":"[MySQL Dialect] Add support for MySQL last_insert_id function (by Kelvin Law ) [PostgreSQL Dialect] Support SERIAL data type (by Veyndan Stuart & Felipe Lima ) [PostgreSQL Dialect] Support PostgreSQL RETURNING (by Veyndan Stuart )","title":"Added"},{"location":"changelog/#fixed_9","text":"[MySQL Dialect] Treat MySQL AUTO_INCREMENT as having a default value (#1823) [Compiler] Fix Upsert statement compiler error (#1809 by Eliezer Graber ) [Compiler] Fix issue with invalid Kotlin being generated (#1925 by Eliezer Graber ) [Compiler] Have a better error message for unknown functions (#1843) [Compiler] Expose string as the type for the second parameter of instr [IDE Plugin] Fix daemon bloat and UI thread stalling for IDE plugin (#1916) [IDE Plugin] Handle null module scenario (#1902) [IDE Plugin] In unconfigured sq files return empty string for the package name (#1920) [IDE Plugin] Fix grouped statements and add an integration test for them (#1820) [IDE Plugin] Use built in ModuleUtil to find the module for an element (#1854) [IDE Plugin] Only add valid elements to lookups (#1909) [IDE Plugin] Parent can be null (#1857)","title":"Fixed"},{"location":"changelog/#142-2020-08-27","text":"","title":"[1.4.2] - 2020-08-27"},{"location":"changelog/#added_11","text":"[Runtime] Support new JS IR backend [Gradle Plugin] Add generateSqlDelightInterface Gradle task. (by Niklas Baudy ) [Gradle Plugin] Add verifySqlDelightMigration Gradle task. (by Niklas Baudy )","title":"Added"},{"location":"changelog/#fixed_10","text":"[IDE Plugin] Use the gradle tooling API to facilitate data sharing between the IDE and gradle [IDE Plugin] Default to false for schema derivation [IDE Plugin] Properly retrieve the commonMain source set [MySQL Dialect] Added minute to mySqlFunctionType() (by MaaxGr )","title":"Fixed"},{"location":"changelog/#141-2020-08-21","text":"","title":"[1.4.1] - 2020-08-21"},{"location":"changelog/#added_12","text":"[Runtime] Support Kotlin 1.4.0 (#1859)","title":"Added"},{"location":"changelog/#changed_9","text":"[Gradle Plugin] Make AGP dependency compileOnly (#1362)","title":"Changed"},{"location":"changelog/#fixed_11","text":"[Compiler] Add optional javadoc to column defintion rule and to table interface generator (#1224 by Daniel Eke ) [SQLite Dialect] Add support for sqlite fts5 auxiliary functions highlight, snippet, and bm25 (by Daniel Rampelt ) [MySQL Dialect] Support MySQL bit data type [MySQL Dialect] Support MySQL binary literals [PostgreSQL Dialect] Expose SERIAL from sql-psi (by Veyndan Stuart ) [PostgreSQL Dialect] Add BOOLEAN data type (by Veyndan Stuart ) [PostgreSQL Dialect] Add NULL column constraint (by Veyndan Stuart ) [HSQL Dialect] Adds AUTO_INCREMENT support to HSQL (by Ryan Harter )","title":"Fixed"},{"location":"changelog/#140-2020-06-22","text":"","title":"[1.4.0] - 2020-06-22"},{"location":"changelog/#added_13","text":"[MySQL Dialect] MySQL support (by Jeff Gulbronson & Veyndan Stuart ) [PostgreSQL Dialect] Experimental PostgreSQL support (by Veyndan Stuart ) [HSQL Dialect] Experimental H2 support (by Marius Volkhart ) [SQLite Dialect] SQLite FTS5 support (by Ben Asher & James Palawaga ) [SQLite Dialect] Support alter table rename column (#1505 by Angus Holder ) [IDE] IDE support for migration (.sqm) files [IDE] Add SQLDelight Live Templates that mimic built-in SQL Live Templates (#1154 by Veyndan Stuart ) [IDE] Add new SqlDelight file action (#42 by Roman Zavarnitsyn ) [Runtime] transactionWithReturn API for transactions that return results [Compiler] Syntax for grouping multiple SQL statements together in a .sq file [Compiler] Support generating schemas from migration files [Gradle Plugin] Add a task for outputting migration files as valid sql","title":"Added"},{"location":"changelog/#changed_10","text":"[Documentation] Overhaul of the documentation website (by Saket Narayan ) [Gradle Plugin] Improve unsupported dialect error message (by Veyndan Stuart ) [IDE] Dynamically change file icon based on dialect (by Veyndan Stuart ) [JDBC Driver] Expose a JdbcDriver constructor off of javax.sql.DataSource (#1614)","title":"Changed"},{"location":"changelog/#fixed_12","text":"[Compiler]Support Javadoc on tables and fix multiple javadoc in one file (#1224) [Compiler] Enable inserting a value for synthesized columns (#1351) [Compiler] Fix inconsistency in directory name sanitizing (by Zac Sweers ) [Compiler] Synthesized columns should retain nullability across joins (#1656) [Compiler] Pin the delete statement on the delete keyword (#1643) [Compiler] Fix quoting (#1525 by Angus Holder ) [Compiler] Fix the between operator to properly recurse into expressions (#1279) [Compiler] Give better error for missing table/column when creating an index (#1372) [Compiler] Enable using the outer querys projection in join constraints (#1346) [Native Driver] Make execute use transationPool (by Ben Asher ) [JDBC Driver] Use the jdbc transaction APIs instead of sqlite (#1693) [IDE] Fix virtualFile references to always be the original file (#1782) [IDE] Use the correct throwable when reporting errors to bugsnag (#1262) [Paging Extension] Fix leaky DataSource (#1628) [Gradle Plugin] If the output db file already exists when generating a schema, delete it (#1645) [Gradle Plugin] Fail migration validation if there are gaps [Gradle Plugin] Explicitely use the file index we set (#1644)","title":"Fixed"},{"location":"changelog/#130-2020-04-03","text":"New: [Gradle] Dialect property to specify with sql dialect to compile against. New: [Compiler] #1009 Experimental support of the mysql dialect. New: [Compiler] #1436 Support of sqlite:3.24 dialect and upsert. New: [JDBC Driver] Split out JDBC driver from sqlite jvm driver. Fix: [Compiler] #1199 Support lambdas of any length. Fix: [Compiler] #1610 Fix the return type of avg() to be nullable. Fix: [IntelliJ] #1594 Fix path separator handling which broke Goto and Find Usages on Windows.","title":"[1.3.0] - 2020-04-03"},{"location":"changelog/#122-2020-01-22","text":"New: [Runtime] Support for Windows (mingW), tvOS, watchOS, and macOS architectures. Fix: [Compiler] Return type of sum() should be nullable. Fix: [Paging] Pass Transacter into QueryDataSourceFactory to avoid race conditions. Fix: [IntelliJ Plugin] Don't search through dependencies when looking for a file's package name. Fix: [Gradle] #862 Change validator logs in Gradle to debug level. Enhancement: [Gradle] Convert GenerateSchemaTask to use Gradle worker. Note: sqldelight-runtime artifact renamed to runtime.","title":"[1.2.2] - 2020-01-22"},{"location":"changelog/#121-2019-12-11","text":"Fix: [Gradle] Kotlin Native 1.3.60 support. Fix: [Gradle] #1287 Warning when syncing. Fix: [Compiler] #1469 SynetheticAccessor creation for query. Fix: [JVM Driver] Fixed memory leak. NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript.","title":"[1.2.1] - 2019-12-11"},{"location":"changelog/#120-2019-08-30","text":"New: [Runtime] Stable Flow api. Fix: [Gradle] Kotlin Native 1.3.50 support. Fix: [Gradle] #1380 Clean build sometimes fails. Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\". Fix: [Compile] #1405 Can't build project if query contains FTS table joined. Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules.","title":"[1.2.0] - 2019-08-30"},{"location":"changelog/#114-2019-07-11","text":"New: [Runtime] Experimental kotlin Flow api. Fix: [Gradle] Kotlin/Native 1.3.40 compatibility. Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand. Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing. Fix: [Gradle] Allow gradle tasks to cache. Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl. Fix: [Compiler] Unique ids are generated for each query deterministically. Fix: [Compiler] Only notify listening queries when a transaction is complete. Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL.","title":"[1.1.4] - 2019-07-11"},{"location":"changelog/#113-2019-04-14","text":"Gradle Metadata 1.0 release.","title":"[1.1.3] - 2019-04-14"},{"location":"changelog/#112-2019-04-14","text":"New: [Runtime] #1267 Logging driver decorator. Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters. Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project. Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43. Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions.","title":"[1.1.2] - 2019-04-14"},{"location":"changelog/#111-2019-03-01","text":"Fix: [Gradle] Fix module dependency compilation for android projects. Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate. Fix: [Compiler] Array types are properly printed.","title":"[1.1.1] - 2019-03-01"},{"location":"changelog/#110-2019-02-27","text":"New: [Gradle] #502 Allow specifying schema module dependencies. Enhancement: [Compiler] #1111 Table errors are sorted before other errors. Fix: [Compiler] #1225 Return the correct type for REAL literals. Fix: [Compiler] #1218 docid propagates through triggers.","title":"[1.1.0] - 2019-02-27"},{"location":"changelog/#103-2019-01-30","text":"Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32. Enhancement: [Runtime] #1190 Expose the mapper from the Query type.","title":"[1.0.3] - 2019-01-30"},{"location":"changelog/#102-2019-01-26","text":"Fix: [Gradle Plugin] Update to kotlin 1.3.20. Fix: [Runtime] Transactions no longer swallow exceptions.","title":"[1.0.2] - 2019-01-26"},{"location":"changelog/#101-2019-01-21","text":"Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration. Enhancement: [Compiler] #1173 Files without a package fail compilation. Fix: [IDE] Properly report IDE errors to Square. Fix: [IDE] #1162 Types in the same package show as error but work fine. Fix: [IDE] #1166 Renaming a table fails with NPE. Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT.","title":"[1.0.1] - 2019-01-21"},{"location":"changelog/#100-2019-01-08","text":"New: Complete overhaul of generated code, now in kotlin. New: RxJava2 extensions artifact. New: Android Paging extensions artifact. New: Kotlin Multiplatform support. New: Android, iOS and JVM SQLite driver artifacts. New: Transaction API.","title":"[1.0.0] - 2019-01-08"},{"location":"changelog/#070-2018-02-12","text":"New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings. New: Statement folding in the IDE. New: Boolean types are now automatically handled. Fix: Remove deprecated marshals from code generation. Fix: Correct 'avg' SQL function type mapping to be REAL. Fix: Correctly detect 'julianday' SQL function.","title":"[0.7.0] - 2018-02-12"},{"location":"changelog/#061-2017-03-22","text":"New: Delete Update and Insert statements without arguments get compiled statements generated. Fix: Using clause within a view used in a subquery doesn't error. Fix: Duplicate types on generated Mapper removed. Fix: Subqueries can be used in expressions that check against arguments.","title":"[0.6.1] - 2017-03-22"},{"location":"changelog/#060-2017-03-06","text":"New: Select queries are now exposed as a SqlDelightStatement factory instead of string constants. New: Query JavaDoc is now copied to statement and mapper factories. New: Emit string constants for view names. Fix: Queries on views which require factories now correctly require those factories are arguments. Fix: Validate the number of arguments to an insert matches the number of columns specified. Fix: Properly encode blob literals used in where clauses. Gradle 3.3 or newer is required for this release.","title":"[0.6.0] - 2017-03-06"},{"location":"changelog/#051-2016-10-24","text":"New: Compiled statements extend an abstract type. Fix: Primitive types in parameters will be boxed if nullable. Fix: All required factories for bind args are present in factory method. Fix: Escaped column names are marshalled correctly.","title":"[0.5.1] - 2016-10-24"},{"location":"changelog/#050-2016-10-19","text":"New: SQLite arguments can be passed typesafely through the Factory New: IntelliJ plugin performs formatting on .sq files New: Support for SQLite timestamp literals Fix: Parameterized types can be clicked through in IntelliJ Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor. Fix: Gradle plugin doesn't crash trying to print exceptions.","title":"[0.5.0] - 2016-10-19"},{"location":"changelog/#044-2016-07-20","text":"New: Native support for shorts as column java type New: Javadoc on generated mappers and factory methods Fix: group_concat and nullif functions have proper nullability Fix: Compatibility with Android Studio 2.2-alpha Fix: WITH RECURSIVE no longer crashes plugin","title":"[0.4.4] - 2016-07-20"},{"location":"changelog/#043-2016-07-07","text":"New: Compilation errors link to source file. New: Right-click to copy SQLDelight code as valid SQLite. New: Javadoc on named statements will appear on generated Strings. Fix: Generated view models include nullability annotations. Fix: Generated code from unions has proper type and nullability to support all possible columns. Fix: sum and round SQLite functions have proper type in generated code. Fix: CAST's, inner selects bugfixes. Fix: Autocomplete in CREATE TABLE statements. Fix: SQLite keywords can be used in packages.","title":"[0.4.3] - 2016-07-07"},{"location":"changelog/#042-2016-06-16","text":"New: Marshal can be created from the factory. Fix: IntelliJ plugin generates factory methods with proper generic order. Fix: Function names can use any casing.","title":"[0.4.2] - 2016-06-16"},{"location":"changelog/#041-2016-06-14","text":"Fix: IntelliJ plugin generates classes with proper generic order. Fix: Column definitions can use any casing.","title":"[0.4.1] - 2016-06-14"},{"location":"changelog/#040-2016-06-14","text":"New: Mappers are generated per query instead of per table. New: Java types can be imported in .sq files. New: SQLite functions are validated. Fix: Remove duplicate errors. Fix: Uppercase column names and java keyword column names do not error.","title":"[0.4.0] - 2016-06-14"},{"location":"changelog/#032-2016-05-14","text":"New: Autocompletion and find usages now work for views and aliases. Fix: Compile-time validation now allows functions to be used in selects. Fix: Support insert statements which only declare default values. Fix: Plugin no longer crashes when a project not using SQLDelight is imported.","title":"[0.3.2] - 2016-05-14"},{"location":"changelog/#031-2016-04-27","text":"Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references. Fix: Subexpressions are evaluated properly.","title":"[0.3.1] - 2016-04-27"},{"location":"changelog/#030-2016-04-26","text":"New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type. New: Bug reports can be sent from the IDE. Fix: Autocomplete functions properly. Fix: SQLDelight model files update on .sq file edit. Removed: Attached databases no longer supported.","title":"[0.3.0] - 2016-04-26"},{"location":"changelog/#022-2016-03-07","text":"New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements. Fix: Don't crash IDE plugin on file move/create.","title":"[0.2.2] - 2016-03-07"},{"location":"changelog/#021-2016-03-07","text":"New: Ctrl+ / (Cmd+ / on OSX) toggles comment of the selected line(s). New: Compile-time validation of the columns used by SQL queries. Fix: Support Windows paths in both the IDE and Gradle plugin.","title":"[0.2.1] - 2016-03-07"},{"location":"changelog/#020-2016-02-29","text":"New: Added copy constructor to Marshal class. New: Update to Kotlin 1.0 final. Fix: Report 'sqldelight' folder structure problems in a non-failing way. Fix: Forbid columns named table_name . Their generated constant clashes with the table name constant. Fix: Ensure IDE plugin generates model classes immediately and regardless of whether .sq files were opened. Fix: Support Windows paths in both the IDE and Gradle plugin.","title":"[0.2.0] - 2016-02-29"},{"location":"changelog/#012-2016-02-13","text":"Fix: Remove code which prevented the Gradle plugin from being used in most projects. Fix: Add missing compiler dependency on the Antlr runtime.","title":"[0.1.2] - 2016-02-13"},{"location":"changelog/#011-2016-02-12","text":"Fix: Ensure the Gradle plugin points to the same version of the runtime as itself.","title":"[0.1.1] - 2016-02-12"},{"location":"changelog/#010-2016-02-12","text":"Initial release.","title":"[0.1.0] - 2016-02-12"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"contributing/","text":"Contributing If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) . SQLDelight If you're looking to get started with contributing, look below for specific guides depending on which part of SQLDelight you'd like to contribute to. If you're still unsure, comment in the issue you're looking in to with where you're getting stuck and we'll respond there - or create an issue for the thing you're trying to do and start the discussion. IDE Plugin If you want to fix a bug or extend the IDE, code changes will likely happen in the sqldelight-idea-plugin module. You can test your changes using the ./gradlew runIde task and you can live debug using ./gradlew runIde --debug-jvm . If you're encountering a bug in the IDE but cannot reproduce it in a sample project, you can live debug your IDE. You'll need a second installation of IntelliJ to do this. You can use Toolbox to do this by scrolling to the bottom of the IDE list and selecting a different version of IntelliJ. In the IDE you'd like to use the debugger in, check out the SQLDelight repo and then create a new Remote Run Configuration. It will already populate \"Command line arguments for remote JVM\", something like -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 . Copy that value, then open the IDE you would like to debug. Select Help -> Edit Custom VM Options , and paste the line you copied to the bottom of the file that is opened. Restart the IDE you want to debug, then once it's started up open the IDE you created the configuration in, and attach the debugger using the remote configuration you created. For more information on building IDE plugins and features for them see the Official Jetbrains Documentation or join the Jetbrains Platform Slack . Drivers If you're interested in creating your own driver, you can do so outside of the SQLDelight repository using the runtime artifact. To test the driver you can depend on the driver-test and extend DriverTest and TransactionTest to ensure it works as SQLDelight would expect. Asynchronous Drivers Drivers that make asynchronous calls can be implemented by using the runtime-async artifact. Gradle If you're encountering a gradle issue, start by creating a test fixture in sqldelight-gradle-plugin/src/test similar to the other folders there which reproduces your issue. Feel free to just open a PR with this failing test if you don't know how to fix! Test cases are greatly appreciated. The integration tests show how to set up an entire gradle project which will run SQLite/MySQL/PostgreSQL/etc and execute SQL queries using their respective runtime environments and SQLDelight. Consider adding a test to these already existing integration tests if you're encountering runtime issues in SQLDelight. Compiler There are many layers to SQLDelight's compiler - if you are strictly interested in the codegen (and not the parsing of SQL) then you will want to make your contributions in the sqldelight-compiler module. If you are interested in the parser you'll need to contribute to sql-psi . SQLDelight uses kotlinpoet for generating kotlin code, be sure to use it's APIs for referencing kotlin types so imports still work correctly. If you modify the codegen in any way, run a ./gradlew build before opening a pull request, as it will update the integration test in sqldelight-compiler:integration-tests . If you'd like to write an integration test (meaning running SQL queries in a runtime environment), add a test to sqldelight-compiler:integration-tests . SQL PSI In the next section we will go through how to contribute to the parser and PSI layer, but before doing that you should read a blog post on multiple dialects to understand the various moving pieces in sql-psi . As with SQLDelight, if you're encountering an issue but don't know how to contribute a fix or need assistance, comment in the GitHub issue or create a new one to start the discussion. For any changes in SQL-PSI, you will want to add a test fixture in the corresponding core/src/test/fixtures_* folder. The fixtures folder (no suffix) runs for all dialects. After your change has been merged to sql-psi, if there are changes you also need to make in SQLDelight, check out the sql-psi-dev branch on SQLDelight and target it with your PR. It uses the snapshot releases of sql-psi so you can build your SQLDelight change roughly 10 minutes after the sql-psi change has been merged. Grammar If you are adding to the grammar, first decide if this is a new rule you are adding to an existing grammar, or a rule you would like to override from ANSI SQL (which is found in sql.bnf ). In both cases, you will want to define that rule in your new grammar, but in the case of overriding an ANSI SQL rule, add it to the overrides list and set the override attribute on the rule: overrides ::= my_rule my_rule ::= SOME_TOKEN { override = true } The definition of your rule should start by being an exact copy/paste of the rule from ANSI-SQL. To reference rules from ANSI-SQL, you need to surround it in {}, so you should surround all external rules in your overriding rule with {}: my_rule ::= internal_rule {external_rule} { override = true } internal_rule ::= SOME_TOKEN One caveat is that referencing the expr rule from ANSI-SQL should look like <<expr '-1'>> because it is special and cannot be overridden. Any tokens that you want to use from ANSI SQL should also be manually imported: { parserImports = [ \"static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE\" \"static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM\" ] } overrides ::= delete delete ::= DELETE FROM {table_name} { override = true } Dialects cannot add their own tokens, but you can require exact text by surrounding it with \"\": my_rule ::= \"SOME_TOKEN\" Overriding rules must still generate code which confirms to the original rules types, so make sure to implement and extend the existing types for the original rule: my_rule ::= internal_rule {external_rule} { extends = \"com.alecstrong.sql.psi.core.psi.impl.SqlMyRuleImpl\" implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\" overrides = true } To see an example of overriding rules in the grammar, check out this pr which adds RETURNING syntax to PostgreSQL. Rule Behavior Often times you want to modify the behavior of the PSI layer (for example throwing errors for situations you want to fail compilation for). To do this, have your rule use a mixin instead of an extends which is a class you write containing that new logic: my_rule ::= interal_rule {external_rule} { mixin = \"com.alecstrong.sql.psi.MyRuleMixin\" implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\" overrides = true } And then in that class ensure that it implements the original ANSI SQL type and the SQL-PSI base class SqlCompositeElementImpl : class MyRule( node: ASTNode ) : SqlCompositeElementImpl(node), SqlMyRule { fun annotate(annotationHolder: SqlAnnotationHolder) { if (internal_rule.text == \"bad_text\") { annotationHolder.createErrorAnnotation(\"Invalid text value\", internal_rule) } } } For example, the DropIndexMixin verifies the index being dropped exists in the schema. If you have a question about contributing not covered in this doc please feel free to open an issue on SqlDelight or open a PR so we can work on improving it!","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#sqldelight","text":"If you're looking to get started with contributing, look below for specific guides depending on which part of SQLDelight you'd like to contribute to. If you're still unsure, comment in the issue you're looking in to with where you're getting stuck and we'll respond there - or create an issue for the thing you're trying to do and start the discussion.","title":"SQLDelight"},{"location":"contributing/#ide-plugin","text":"If you want to fix a bug or extend the IDE, code changes will likely happen in the sqldelight-idea-plugin module. You can test your changes using the ./gradlew runIde task and you can live debug using ./gradlew runIde --debug-jvm . If you're encountering a bug in the IDE but cannot reproduce it in a sample project, you can live debug your IDE. You'll need a second installation of IntelliJ to do this. You can use Toolbox to do this by scrolling to the bottom of the IDE list and selecting a different version of IntelliJ. In the IDE you'd like to use the debugger in, check out the SQLDelight repo and then create a new Remote Run Configuration. It will already populate \"Command line arguments for remote JVM\", something like -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 . Copy that value, then open the IDE you would like to debug. Select Help -> Edit Custom VM Options , and paste the line you copied to the bottom of the file that is opened. Restart the IDE you want to debug, then once it's started up open the IDE you created the configuration in, and attach the debugger using the remote configuration you created. For more information on building IDE plugins and features for them see the Official Jetbrains Documentation or join the Jetbrains Platform Slack .","title":"IDE Plugin"},{"location":"contributing/#drivers","text":"If you're interested in creating your own driver, you can do so outside of the SQLDelight repository using the runtime artifact. To test the driver you can depend on the driver-test and extend DriverTest and TransactionTest to ensure it works as SQLDelight would expect.","title":"Drivers"},{"location":"contributing/#asynchronous-drivers","text":"Drivers that make asynchronous calls can be implemented by using the runtime-async artifact.","title":"Asynchronous Drivers"},{"location":"contributing/#gradle","text":"If you're encountering a gradle issue, start by creating a test fixture in sqldelight-gradle-plugin/src/test similar to the other folders there which reproduces your issue. Feel free to just open a PR with this failing test if you don't know how to fix! Test cases are greatly appreciated. The integration tests show how to set up an entire gradle project which will run SQLite/MySQL/PostgreSQL/etc and execute SQL queries using their respective runtime environments and SQLDelight. Consider adding a test to these already existing integration tests if you're encountering runtime issues in SQLDelight.","title":"Gradle"},{"location":"contributing/#compiler","text":"There are many layers to SQLDelight's compiler - if you are strictly interested in the codegen (and not the parsing of SQL) then you will want to make your contributions in the sqldelight-compiler module. If you are interested in the parser you'll need to contribute to sql-psi . SQLDelight uses kotlinpoet for generating kotlin code, be sure to use it's APIs for referencing kotlin types so imports still work correctly. If you modify the codegen in any way, run a ./gradlew build before opening a pull request, as it will update the integration test in sqldelight-compiler:integration-tests . If you'd like to write an integration test (meaning running SQL queries in a runtime environment), add a test to sqldelight-compiler:integration-tests .","title":"Compiler"},{"location":"contributing/#sql-psi","text":"In the next section we will go through how to contribute to the parser and PSI layer, but before doing that you should read a blog post on multiple dialects to understand the various moving pieces in sql-psi . As with SQLDelight, if you're encountering an issue but don't know how to contribute a fix or need assistance, comment in the GitHub issue or create a new one to start the discussion. For any changes in SQL-PSI, you will want to add a test fixture in the corresponding core/src/test/fixtures_* folder. The fixtures folder (no suffix) runs for all dialects. After your change has been merged to sql-psi, if there are changes you also need to make in SQLDelight, check out the sql-psi-dev branch on SQLDelight and target it with your PR. It uses the snapshot releases of sql-psi so you can build your SQLDelight change roughly 10 minutes after the sql-psi change has been merged.","title":"SQL PSI"},{"location":"contributing/#grammar","text":"If you are adding to the grammar, first decide if this is a new rule you are adding to an existing grammar, or a rule you would like to override from ANSI SQL (which is found in sql.bnf ). In both cases, you will want to define that rule in your new grammar, but in the case of overriding an ANSI SQL rule, add it to the overrides list and set the override attribute on the rule: overrides ::= my_rule my_rule ::= SOME_TOKEN { override = true } The definition of your rule should start by being an exact copy/paste of the rule from ANSI-SQL. To reference rules from ANSI-SQL, you need to surround it in {}, so you should surround all external rules in your overriding rule with {}: my_rule ::= internal_rule {external_rule} { override = true } internal_rule ::= SOME_TOKEN One caveat is that referencing the expr rule from ANSI-SQL should look like <<expr '-1'>> because it is special and cannot be overridden. Any tokens that you want to use from ANSI SQL should also be manually imported: { parserImports = [ \"static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE\" \"static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM\" ] } overrides ::= delete delete ::= DELETE FROM {table_name} { override = true } Dialects cannot add their own tokens, but you can require exact text by surrounding it with \"\": my_rule ::= \"SOME_TOKEN\" Overriding rules must still generate code which confirms to the original rules types, so make sure to implement and extend the existing types for the original rule: my_rule ::= internal_rule {external_rule} { extends = \"com.alecstrong.sql.psi.core.psi.impl.SqlMyRuleImpl\" implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\" overrides = true } To see an example of overriding rules in the grammar, check out this pr which adds RETURNING syntax to PostgreSQL.","title":"Grammar"},{"location":"contributing/#rule-behavior","text":"Often times you want to modify the behavior of the PSI layer (for example throwing errors for situations you want to fail compilation for). To do this, have your rule use a mixin instead of an extends which is a class you write containing that new logic: my_rule ::= interal_rule {external_rule} { mixin = \"com.alecstrong.sql.psi.MyRuleMixin\" implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\" overrides = true } And then in that class ensure that it implements the original ANSI SQL type and the SQL-PSI base class SqlCompositeElementImpl : class MyRule( node: ASTNode ) : SqlCompositeElementImpl(node), SqlMyRule { fun annotate(annotationHolder: SqlAnnotationHolder) { if (internal_rule.text == \"bad_text\") { annotationHolder.createErrorAnnotation(\"Invalid text value\", internal_rule) } } } For example, the DropIndexMixin verifies the index being dropped exists in the schema. If you have a question about contributing not covered in this doc please feel free to open an issue on SqlDelight or open a PR so we can work on improving it!","title":"Rule Behavior"},{"location":"android_sqlite/","text":"Getting Started on Android First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) It's recommended to switch Android Studio to use the \"Project\" view instead of the \"Android\" view of your files, in order to find and edit SQLDelight files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"android_sqlite/#getting-started-on-android","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) It's recommended to switch Android Studio to use the \"Project\" view instead of the \"Android\" view of your files, in order to find and edit SQLDelight files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started on Android"},{"location":"android_sqlite/androidx_paging/","text":"AndroidX Paging To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:androidx-paging3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.0.0-alpha04\" } SQLDelight offers two methods for paging data -- offset based paging and keyset paging. Offset Based Paging Offset paging achieves paged results using OFFSET and LIMIT clauses. Creating a PagingSource that performs offset based paging requires a count query as well as the paged query. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; import app.cash.sqldelight.android.paging3.QueryPagingSource val pagingSource : PagingSource = QueryPagingSource ( countQuery = playerQueries . countPlayers (), transacter = playerQueries , context = Dispatchers . IO , queryProvider = playerQueries :: players , ) By default, queries are performed on Dispatchers.IO if no context is specified. Consumers expecting to use RxJava's Scheduler to perform queries should use the Scheduler.asCoroutineDispatcher extension function. Keyset Paging Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The OFFSET clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to OFFSET grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of PagingSource . Rather than querying an entire dataset and inefficiently dropping the first OFFSET elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. The queryProvider callback that this paging source accepts has two parameters -- a beginInclusive non-null unique Key as well as an endExclusive nullable unique Key? . An example of the core paging query is shown below. keyedQuery : SELECT * FROM hockeyPlayer WHERE id >= : beginInclusive AND ( id < : endExclusive OR : endExclusive IS NULL ) ORDER BY id ASC ; Queries used in keyset paging must have a unique ordering like shown above. Both beginInclusive and endExclusive are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The pageBoundariesProvider callback takes an anchor: Key? parameter as well as a limit: Int? parameter. An example query that pre-calculates page boundaries is shown below. pageBoundaries : SELECT id FROM ( SELECT id , CASE WHEN (( row_number () OVER ( ORDER BY id ASC ) - 0 ) % : limit ) = 0 THEN 1 WHEN id = : anchor THEN 1 ELSE 0 END page_boundary ; FROM hockeyPlayer ORDER BY id ASC ) WHERE page_boundary = 1 ; Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions . Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting minApi 30 or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with PagingConfig.initialLoadSize . This functionality should be avoided , as the pageBoundariesProvider callback is invoked a single time on the first page fetch. Failing to have matching PagingConifg.initialLoadSize and PagingConfig.pageSize will result in unexpected page boundary generation. This paging source does not support jumping. To create this paging source, use the QueryPagingSource factory function. import app.cash.sqldelight.android.paging3.QueryPagingSource val keyedSource = QueryPagingSource ( transacter = playerQueries , context = Dispatchers . IO , pageBoundariesProvider = playerQueries :: pageBoundaries , queryProvider = playerQueries :: keyedQuery , ) By default, queries are performed on Dispatchers.IO if no context is specified. Consumers expecting to use RxJava's Scheduler to perform queries should use the Scheduler.asCoroutineDispatcher extension function.","title":"AndroidX Paging"},{"location":"android_sqlite/androidx_paging/#androidx-paging","text":"To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:androidx-paging3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.0.0-alpha04\" } SQLDelight offers two methods for paging data -- offset based paging and keyset paging.","title":"AndroidX Paging"},{"location":"android_sqlite/androidx_paging/#offset-based-paging","text":"Offset paging achieves paged results using OFFSET and LIMIT clauses. Creating a PagingSource that performs offset based paging requires a count query as well as the paged query. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; import app.cash.sqldelight.android.paging3.QueryPagingSource val pagingSource : PagingSource = QueryPagingSource ( countQuery = playerQueries . countPlayers (), transacter = playerQueries , context = Dispatchers . IO , queryProvider = playerQueries :: players , ) By default, queries are performed on Dispatchers.IO if no context is specified. Consumers expecting to use RxJava's Scheduler to perform queries should use the Scheduler.asCoroutineDispatcher extension function.","title":"Offset Based Paging"},{"location":"android_sqlite/androidx_paging/#keyset-paging","text":"Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The OFFSET clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to OFFSET grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of PagingSource . Rather than querying an entire dataset and inefficiently dropping the first OFFSET elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. The queryProvider callback that this paging source accepts has two parameters -- a beginInclusive non-null unique Key as well as an endExclusive nullable unique Key? . An example of the core paging query is shown below. keyedQuery : SELECT * FROM hockeyPlayer WHERE id >= : beginInclusive AND ( id < : endExclusive OR : endExclusive IS NULL ) ORDER BY id ASC ; Queries used in keyset paging must have a unique ordering like shown above. Both beginInclusive and endExclusive are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The pageBoundariesProvider callback takes an anchor: Key? parameter as well as a limit: Int? parameter. An example query that pre-calculates page boundaries is shown below. pageBoundaries : SELECT id FROM ( SELECT id , CASE WHEN (( row_number () OVER ( ORDER BY id ASC ) - 0 ) % : limit ) = 0 THEN 1 WHEN id = : anchor THEN 1 ELSE 0 END page_boundary ; FROM hockeyPlayer ORDER BY id ASC ) WHERE page_boundary = 1 ; Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions . Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting minApi 30 or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with PagingConfig.initialLoadSize . This functionality should be avoided , as the pageBoundariesProvider callback is invoked a single time on the first page fetch. Failing to have matching PagingConifg.initialLoadSize and PagingConfig.pageSize will result in unexpected page boundary generation. This paging source does not support jumping. To create this paging source, use the QueryPagingSource factory function. import app.cash.sqldelight.android.paging3.QueryPagingSource val keyedSource = QueryPagingSource ( transacter = playerQueries , context = Dispatchers . IO , pageBoundariesProvider = playerQueries :: pageBoundaries , queryProvider = playerQueries :: keyedQuery , ) By default, queries are performed on Dispatchers.IO if no context is specified. Consumers expecting to use RxJava's Scheduler to perform queries should use the Scheduler.asCoroutineDispatcher extension function.","title":"Keyset Paging"},{"location":"android_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"android_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"android_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"android_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"android_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"android_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"android_sqlite/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"android_sqlite/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"android_sqlite/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"android_sqlite/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"android_sqlite/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"android_sqlite/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"android_sqlite/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"android_sqlite/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"android_sqlite/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"android_sqlite/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"android_sqlite/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"android_sqlite/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"android_sqlite/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"android_sqlite/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"android_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"android_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"android_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"android_sqlite/migrations/","text":"Migrations An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration. Code Migrations If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6. If you are using an AndroidSqliteDriver you can pass these callbacks in during the driver's creation: val driver : SqlDriver = AndroidSqliteDriver ( schema = Database . Schema , context = context , name = \"test.db\" , callback = AndroidSqliteDriver . Callback ( schema = Database . Schema , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) )","title":"Migrations"},{"location":"android_sqlite/migrations/#migrations","text":"An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers.","title":"Migrations"},{"location":"android_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"android_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"android_sqlite/migrations/#code-migrations","text":"If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6. If you are using an AndroidSqliteDriver you can pass these callbacks in during the driver's creation: val driver : SqlDriver = AndroidSqliteDriver ( schema = Database . Schema , context = context , name = \"test.db\" , callback = AndroidSqliteDriver . Callback ( schema = Database . Schema , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) )","title":"Code Migrations"},{"location":"android_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"android_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"android_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"android_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"android_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"android_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"android_sqlite/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"android_sqlite/resources/","text":"Other Resources Guides SQLDelight 1.x Quickstart Guide for Android","title":"Resources"},{"location":"android_sqlite/resources/#other-resources","text":"","title":"Other Resources"},{"location":"android_sqlite/resources/#guides","text":"SQLDelight 1.x Quickstart Guide for Android","title":"Guides"},{"location":"android_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"android_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"android_sqlite/testing/","text":"In some tests (like verification of migrations) you might wish to swap out the Android driver with the JVM driver , enabling you to test code involving the database without needing an Android emulator or physical device. To do that use the jvm SQLite driver: Kotlin Groovy dependencies { testImplementation ( \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" ) } dependencies { testImplementation \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" } // When your test needs a driver @Before fun before () { driver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) } If you are using the SQLite that comes bundled with Android (rather than shipping your own ), you can override the version of sqlite-jdbc to one that matches your Android minSdkVersion , for example for API 23 use SQLite 3.8.10.2: dependencies { testImplementation ( 'org.xerial:sqlite-jdbc:3.8.10.2' ) { // Override the version of sqlite used by sqlite-driver to match Android API 23 force = true } }","title":"Testing"},{"location":"android_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"android_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"android_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"android_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray ); Primitives A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"android_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray );","title":"SQLite Types"},{"location":"android_sqlite/types/#primitives","text":"A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Primitives"},{"location":"android_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"android_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"android_sqlite/upgrading/","text":"Upgrading from Versions before 1.0 If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading Pre-1.0"},{"location":"android_sqlite/upgrading/#upgrading-from-versions-before-10","text":"If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading from Versions before 1.0"},{"location":"common/coroutines-multiplatform/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines multiplatform"},{"location":"common/coroutines-multiplatform/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"common/coroutines-usage/","text":"val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines usage"},{"location":"common/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"common/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"common/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom column types"},{"location":"common/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"common/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"common/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"common/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"common/gradle-dependencies/","text":"Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle dependencies"},{"location":"common/gradle-dependencies/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"common/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"common/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"common/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"common/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"common/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"common/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"common/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"common/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"common/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"common/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"common/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"common/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"common/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"common/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"common/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"common/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"common/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping statements"},{"location":"common/index_gradle_database/","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } }","title":"Index gradle database"},{"location":"common/index_queries/","text":"SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Index queries"},{"location":"common/index_schema/","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:","title":"Index schema"},{"location":"common/index_schema_sq/","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' );","title":"Index schema sq"},{"location":"common/index_server/","text":"SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ). Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Index server"},{"location":"common/index_server/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"common/index_server/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"common/index_server/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"common/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"common/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"common/migrations/","text":"Migrations An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration. Code Migrations If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Migrations"},{"location":"common/migrations/#migrations","text":"An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers.","title":"Migrations"},{"location":"common/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"common/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"common/migrations/#code-migrations","text":"If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Code Migrations"},{"location":"common/migrations_server/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations server"},{"location":"common/migrations_server/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"common/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"app.cash.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory.","title":"Multiplatform"},{"location":"common/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"app.cash.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory.","title":"Multiplatform"},{"location":"common/query_arguments/","text":"Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Query arguments"},{"location":"common/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"common/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"common/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"common/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"common/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"common/query_arguments_sqlite/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Query arguments sqlite"},{"location":"common/query_arguments_sqlite/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"common/query_arguments_sqlite/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"common/query_arguments_sqlite/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"common/query_arguments_sqlite/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"common/query_arguments_sqlite/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"common/query_arguments_sqlite/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"common/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"common/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"common/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"common/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"common/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"common/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"common/types_server_migrations/","text":"Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types server migrations"},{"location":"common/types_server_migrations/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"common/types_sqlite/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray ); Primitives A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Types sqlite"},{"location":"common/types_sqlite/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray );","title":"SQLite Types"},{"location":"common/types_sqlite/#primitives","text":"A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Primitives"},{"location":"js_sqlite/","text":"Getting started on Kotlin JS with SQLDelight First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy kotlin { sourceSets . jsMain . dependencies { implementation ( \"app.cash.sqldelight:sqljs-driver:2.0.0-alpha04\" ) implementation ( npm ( \"sql.js\" , \"1.6.2\" )) implementation ( devNpm ( \"copy-webpack-plugin\" , \"9.1.0\" )) } } kotlin { sourceSets . jsMain . dependencies { implementation \"app.cash.sqldelight:sqljs-driver:2.0.0-alpha04\" implementation npm ( \"sql.js\" , \"1.6.2\" ) implementation devNpm ( \"copy-webpack-plugin\" , \"9.1.0\" ) } } Unlike on other platforms, the SqlJs driver can not be instantiated directly. The driver must be loaded asynchronously by calling the initSqlDriver function which returns a Promise<SqlDriver> . // As a Promise val promise : Promise < SqlDriver > = initSqlDriver ( Database . Schema ) promise . then { driver -> /* ... */ } // In a coroutine suspend fun createDriver () { val driver : SqlDriver = initSqlDriver ( Database . Schema ). await () /* ... */ } If building for browsers, some additional webpack configuration is also required. // project/webpack.config.d/fs.js config . resolve = { fallback : { fs : false , path : false , crypto : false , } }; // project/webpack.config.d/wasm.js const CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); config . plugins . push ( new CopyWebpackPlugin ({ patterns : [ '../../node_modules/sql.js/dist/sql-wasm.wasm' ] }) ); For browser testing with Karma, some similar configuration is required. // project/karma.config.d/wasm.js const path = require ( \"path\" ); const abs = path . resolve ( \"../../node_modules/sql.js/dist/sql-wasm.wasm\" ) config . files . push ({ pattern : abs , served : true , watched : false , included : false , nocache : false , }); config . proxies [ \"/sql-wasm.wasm\" ] = `/absolute ${ abs } ` SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"js_sqlite/#getting-started-on-kotlin-js-with-sqldelight","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy kotlin { sourceSets . jsMain . dependencies { implementation ( \"app.cash.sqldelight:sqljs-driver:2.0.0-alpha04\" ) implementation ( npm ( \"sql.js\" , \"1.6.2\" )) implementation ( devNpm ( \"copy-webpack-plugin\" , \"9.1.0\" )) } } kotlin { sourceSets . jsMain . dependencies { implementation \"app.cash.sqldelight:sqljs-driver:2.0.0-alpha04\" implementation npm ( \"sql.js\" , \"1.6.2\" ) implementation devNpm ( \"copy-webpack-plugin\" , \"9.1.0\" ) } } Unlike on other platforms, the SqlJs driver can not be instantiated directly. The driver must be loaded asynchronously by calling the initSqlDriver function which returns a Promise<SqlDriver> . // As a Promise val promise : Promise < SqlDriver > = initSqlDriver ( Database . Schema ) promise . then { driver -> /* ... */ } // In a coroutine suspend fun createDriver () { val driver : SqlDriver = initSqlDriver ( Database . Schema ). await () /* ... */ } If building for browsers, some additional webpack configuration is also required. // project/webpack.config.d/fs.js config . resolve = { fallback : { fs : false , path : false , crypto : false , } }; // project/webpack.config.d/wasm.js const CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); config . plugins . push ( new CopyWebpackPlugin ({ patterns : [ '../../node_modules/sql.js/dist/sql-wasm.wasm' ] }) ); For browser testing with Karma, some similar configuration is required. // project/karma.config.d/wasm.js const path = require ( \"path\" ); const abs = path . resolve ( \"../../node_modules/sql.js/dist/sql-wasm.wasm\" ) config . files . push ({ pattern : abs , served : true , watched : false , included : false , nocache : false , }); config . proxies [ \"/sql-wasm.wasm\" ] = `/absolute ${ abs } ` SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting started on Kotlin JS with SQLDelight"},{"location":"js_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"js_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"js_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"js_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"js_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"js_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"js_sqlite/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"js_sqlite/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"js_sqlite/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"js_sqlite/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"js_sqlite/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"js_sqlite/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"js_sqlite/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"js_sqlite/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"js_sqlite/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"js_sqlite/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"js_sqlite/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"js_sqlite/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"js_sqlite/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"js_sqlite/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"js_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"js_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"js_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"js_sqlite/migrations/","text":"Migrations An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration. Code Migrations If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Migrations"},{"location":"js_sqlite/migrations/#migrations","text":"An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers.","title":"Migrations"},{"location":"js_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"js_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"js_sqlite/migrations/#code-migrations","text":"If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Code Migrations"},{"location":"js_sqlite/multiplatform/","text":"Multiplatform setup with the SqlJs Driver First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" } sourceSets . jvmMain . dependencies { implementation \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" } sourceSets . jsMain . dependencies { implementation \"app.cash.sqldelight:sqljs-driver:2.0.0-alpha04\" implementation npm ( \"sql.js\" , \"1.6.2\" ) implementation devNpm ( \"copy-webpack-plugin\" , \"9.1.0\" ) } } Because the SqlJs driver must be initialized asynchronously, the drivers for other platforms must be initialized in a compatible way to be usable in a common source set. The drivers can be initialized in a coroutine, and a higher-order function can be used to ensure that the driver is initialized before executing a block of code that requires the database: // in src/commonMain/kotlin expect suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver class SharedDatabase ( private val driverProvider : suspend ( SqlDriver . Schema ) -> SqlDriver ) { private var database : Database? = null suspend fun initDatabase () { if ( database == null ) { database = driverProvider ( Database . Schema ). createDatabase () } } suspend operator fun < R > invoke ( block : suspend ( Database ) -> R ): R { initDatabase () return block ( database !! ) } private fun SqlDriver . createDatabase (): Database { /* ... */ } } val sharedDb = SharedDatabase ( :: createTestDbDriver ) class DataRepository ( private val withDatabase : SharedDatabase = sharedDb ) { suspend fun getData () = withDatabase { database -> /* Do something with the database */ } } // in src/jsMain/kotlin actual suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver { return initSqlDriver ( schema ). await () } // in src/nativeMain/kotlin actual suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver { return NativeSqliteDriver ( schema , \"test.db\" ) } // in src/jvmMain/kotlin actual suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver { return JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ). also { driver -> schema . create ( driver ) } }","title":"Multiplatform"},{"location":"js_sqlite/multiplatform/#multiplatform-setup-with-the-sqljs-driver","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" } sourceSets . jvmMain . dependencies { implementation \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" } sourceSets . jsMain . dependencies { implementation \"app.cash.sqldelight:sqljs-driver:2.0.0-alpha04\" implementation npm ( \"sql.js\" , \"1.6.2\" ) implementation devNpm ( \"copy-webpack-plugin\" , \"9.1.0\" ) } } Because the SqlJs driver must be initialized asynchronously, the drivers for other platforms must be initialized in a compatible way to be usable in a common source set. The drivers can be initialized in a coroutine, and a higher-order function can be used to ensure that the driver is initialized before executing a block of code that requires the database: // in src/commonMain/kotlin expect suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver class SharedDatabase ( private val driverProvider : suspend ( SqlDriver . Schema ) -> SqlDriver ) { private var database : Database? = null suspend fun initDatabase () { if ( database == null ) { database = driverProvider ( Database . Schema ). createDatabase () } } suspend operator fun < R > invoke ( block : suspend ( Database ) -> R ): R { initDatabase () return block ( database !! ) } private fun SqlDriver . createDatabase (): Database { /* ... */ } } val sharedDb = SharedDatabase ( :: createTestDbDriver ) class DataRepository ( private val withDatabase : SharedDatabase = sharedDb ) { suspend fun getData () = withDatabase { database -> /* Do something with the database */ } } // in src/jsMain/kotlin actual suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver { return initSqlDriver ( schema ). await () } // in src/nativeMain/kotlin actual suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver { return NativeSqliteDriver ( schema , \"test.db\" ) } // in src/jvmMain/kotlin actual suspend fun provideDbDriver ( schema : SqlDriver . Schema ): SqlDriver { return JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ). also { driver -> schema . create ( driver ) } }","title":"Multiplatform setup with the SqlJs Driver"},{"location":"js_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"js_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"js_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"js_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"js_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"js_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"js_sqlite/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"js_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"js_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"js_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"js_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"js_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray ); Primitives A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"js_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray );","title":"SQLite Types"},{"location":"js_sqlite/types/#primitives","text":"A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Primitives"},{"location":"js_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"js_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"js_sqlite/worker/","text":"Running in a Web Worker To use the SqlJs driver with sql.js running in a web worker, first update your gradle configuration to generate asynchronous SQLDelight interfaces. sqldelight { Database { packageName = \"com.example\" generateAsync = true } } The web worker driver only works with browser targets. In addition to the base webpack configuration needed for the SqlJs driver, the web worker script must also be copied. // project/webpack.config.d/wasm.js const CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); config . plugins . push ( new CopyWebpackPlugin ({ patterns : [ '../../node_modules/sql.js/dist/sql-wasm.wasm' , '../../node_modules/sql.js/dist/worker.sql-wasm.js' ] }) ); The function to initialize the driver is a suspend function and must be called within a coroutine. Since this driver is asynchronous, all query functions are also suspend functions. suspend fun setupDb (): AsyncSqlDriver { return initAsyncSqlDriver ( schema = Database . Schema ) } suspend fun getData ( database : Database ): List < MyData > { return database . myDataQueries . getAll (). executeAsList () } Custom Workers By default, the js worker driver will load a web worker from /worker.sql-wasm.js (the additional file copied in the webpack config). The driver supports loading custom workers, or workers located at a different path by providing the URL to the initAsyncSqlDriver() function. initAsyncSqlDriver ( workerPath = \"/path/to/my/worker.js\" ) Custom workers must be able to receive and process messages sent by the driver that are defined in the WorkerMessage interface. The driver expects a responding message to be sent that matches the WorkerData interface. Testing To run karma tests with the web worker, the karma config must be updated to copy and proxy the worker script file in addition to the WebAssembly file. // project/karma.config.d/wasm.js const path = require ( \"path\" ); const dist = path . resolve ( \"../../node_modules/sql.js/dist/\" ) const wasm = path . join ( dist , \"sql-wasm.wasm\" ) const worker = path . join ( dist , \"worker.sql-wasm.js\" ) config . files . push ({ pattern : wasm , served : true , watched : false , included : false , nocache : false , }, { pattern : worker , served : true , watched : false , included : false , nocache : false , }); config . proxies [ \"/sql-wasm.wasm\" ] = `/absolute ${ wasm } ` config . proxies [ \"/worker.sql-wasm.js\" ] = `/absolute ${ worker } `","title":"Web Workers"},{"location":"js_sqlite/worker/#running-in-a-web-worker","text":"To use the SqlJs driver with sql.js running in a web worker, first update your gradle configuration to generate asynchronous SQLDelight interfaces. sqldelight { Database { packageName = \"com.example\" generateAsync = true } } The web worker driver only works with browser targets. In addition to the base webpack configuration needed for the SqlJs driver, the web worker script must also be copied. // project/webpack.config.d/wasm.js const CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); config . plugins . push ( new CopyWebpackPlugin ({ patterns : [ '../../node_modules/sql.js/dist/sql-wasm.wasm' , '../../node_modules/sql.js/dist/worker.sql-wasm.js' ] }) ); The function to initialize the driver is a suspend function and must be called within a coroutine. Since this driver is asynchronous, all query functions are also suspend functions. suspend fun setupDb (): AsyncSqlDriver { return initAsyncSqlDriver ( schema = Database . Schema ) } suspend fun getData ( database : Database ): List < MyData > { return database . myDataQueries . getAll (). executeAsList () }","title":"Running in a Web Worker"},{"location":"js_sqlite/worker/#custom-workers","text":"By default, the js worker driver will load a web worker from /worker.sql-wasm.js (the additional file copied in the webpack config). The driver supports loading custom workers, or workers located at a different path by providing the URL to the initAsyncSqlDriver() function. initAsyncSqlDriver ( workerPath = \"/path/to/my/worker.js\" ) Custom workers must be able to receive and process messages sent by the driver that are defined in the WorkerMessage interface. The driver expects a responding message to be sent that matches the WorkerData interface.","title":"Custom Workers"},{"location":"js_sqlite/worker/#testing","text":"To run karma tests with the web worker, the karma config must be updated to copy and proxy the worker script file in addition to the WebAssembly file. // project/karma.config.d/wasm.js const path = require ( \"path\" ); const dist = path . resolve ( \"../../node_modules/sql.js/dist/\" ) const wasm = path . join ( dist , \"sql-wasm.wasm\" ) const worker = path . join ( dist , \"worker.sql-wasm.js\" ) config . files . push ({ pattern : wasm , served : true , watched : false , included : false , nocache : false , }, { pattern : worker , served : true , watched : false , included : false , nocache : false , }); config . proxies [ \"/sql-wasm.wasm\" ] = `/absolute ${ wasm } ` config . proxies [ \"/worker.sql-wasm.js\" ] = `/absolute ${ worker } `","title":"Testing"},{"location":"jvm_h2/","text":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi Getting Started with H2 First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" dialect = \"app.cash.sqldelight:hsql-dialect:2.0.0-alpha04\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"app.cash.sqldelight:hsql-dialect:2.0.0-alpha04\" } } SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ). Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_h2/#in-development","text":"H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT"},{"location":"jvm_h2/#getting-started-with-h2","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" dialect = \"app.cash.sqldelight:hsql-dialect:2.0.0-alpha04\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"app.cash.sqldelight:hsql-dialect:2.0.0-alpha04\" } } SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ).","title":"Getting Started with H2"},{"location":"jvm_h2/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_h2/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_h2/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_h2/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_h2/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_h2/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"jvm_h2/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"jvm_h2/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"jvm_h2/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"jvm_h2/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"jvm_h2/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"jvm_h2/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"jvm_h2/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"jvm_h2/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"jvm_h2/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"jvm_h2/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"jvm_h2/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"jvm_h2/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"jvm_h2/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"jvm_h2/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"jvm_h2/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"jvm_h2/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_h2/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_h2/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_h2/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_h2/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_h2/query_arguments/","text":"Bind Args .sq files use the exact same syntax as H2, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"jvm_h2/query_arguments/#bind-args","text":".sq files use the exact same syntax as H2, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_h2/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_h2/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_h2/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_h2/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_h2/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"jvm_h2/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_h2/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_h2/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_h2/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_h2/types/","text":"MySQL Types SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Byte some_small_int SMALLINT , -- Retrieved as Short some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL ( 6 , 5 ), -- Retrieved as Int some_dec DEC ( 6 , 5 ), -- Retrieved as Int some_numeric NUMERIC ( 6 , 5 ), -- Retrieved as Int some_float FLOAT ( 6 ), -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_double_precision DOUBLE PRECISION , -- Retrieved as Double some_boolean BOOLEAN , -- Retrieved as Boolean some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp2 TIMESTAMP ( 6 ), -- Retrieved as String some_char CHAR , -- Retrieved as String some_character CHARACTER ( 6 ), -- Retrieved as String some_char_varying CHAR VARYING ( 6 ), -- Retrieved as String some_longvarchar LONGVARCHAR , -- Retrieved as String some_character_varying CHARACTER VARYING ( 6 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_clo CHARACTER LARGE OBJECT ( 16 ), -- Retrieved as String some_clob clob ( 16 M CHARACTERS ), -- Retrieved as String some_binary BINARY , -- Retrieved as ByteArray some_binary2 BINARY ( 6 ), -- Retrieved as ByteArray some_longvarbinary LONGVARBINARY , -- Retrieved as ByteArray some_longvarbinary2 LONGVARBINARY ( 6 ), -- Retrieved as ByteArray some_binary_varying BINARY VARYING ( 6 ), -- Retrieved as ByteArray some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_uuid UUID , -- Retrieved as ByteArray some_blob BLOB , -- Retrieved as ByteArray some_blo BINARY LARGE OBJECT ( 6 ), -- Retrieved as ByteArray some_bit BIT , -- Retrieved as ByteArray some_bit2 BIT ( 6 ), -- Retrieved as ByteArray some_bit_varying BIT VARYING ( 6 ), -- Retrieved as ByteArray some_interval INTERVAL YEAR TO MONTH , -- Retrieved as ByteArray some_interval2 INTERVAL YEAR ( 3 ), -- Retrieved as ByteArray some_interval3 INTERVAL DAY ( 4 ) TO HOUR , -- Retrieved as ByteArray some_interval4 INTERVAL MINUTE ( 4 ) TO SECOND ( 6 ), -- Retrieved as ByteArray some_interval5 INTERVAL SECOND ( 4 , 6 ) -- Retrieved as ByteArray ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_h2/types/#mysql-types","text":"SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Byte some_small_int SMALLINT , -- Retrieved as Short some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL ( 6 , 5 ), -- Retrieved as Int some_dec DEC ( 6 , 5 ), -- Retrieved as Int some_numeric NUMERIC ( 6 , 5 ), -- Retrieved as Int some_float FLOAT ( 6 ), -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_double_precision DOUBLE PRECISION , -- Retrieved as Double some_boolean BOOLEAN , -- Retrieved as Boolean some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp2 TIMESTAMP ( 6 ), -- Retrieved as String some_char CHAR , -- Retrieved as String some_character CHARACTER ( 6 ), -- Retrieved as String some_char_varying CHAR VARYING ( 6 ), -- Retrieved as String some_longvarchar LONGVARCHAR , -- Retrieved as String some_character_varying CHARACTER VARYING ( 6 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_clo CHARACTER LARGE OBJECT ( 16 ), -- Retrieved as String some_clob clob ( 16 M CHARACTERS ), -- Retrieved as String some_binary BINARY , -- Retrieved as ByteArray some_binary2 BINARY ( 6 ), -- Retrieved as ByteArray some_longvarbinary LONGVARBINARY , -- Retrieved as ByteArray some_longvarbinary2 LONGVARBINARY ( 6 ), -- Retrieved as ByteArray some_binary_varying BINARY VARYING ( 6 ), -- Retrieved as ByteArray some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_uuid UUID , -- Retrieved as ByteArray some_blob BLOB , -- Retrieved as ByteArray some_blo BINARY LARGE OBJECT ( 6 ), -- Retrieved as ByteArray some_bit BIT , -- Retrieved as ByteArray some_bit2 BIT ( 6 ), -- Retrieved as ByteArray some_bit_varying BIT VARYING ( 6 ), -- Retrieved as ByteArray some_interval INTERVAL YEAR TO MONTH , -- Retrieved as ByteArray some_interval2 INTERVAL YEAR ( 3 ), -- Retrieved as ByteArray some_interval3 INTERVAL DAY ( 4 ) TO HOUR , -- Retrieved as ByteArray some_interval4 INTERVAL MINUTE ( 4 ) TO SECOND ( 6 ), -- Retrieved as ByteArray some_interval5 INTERVAL SECOND ( 4 , 6 ) -- Retrieved as ByteArray );","title":"MySQL Types"},{"location":"jvm_h2/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_h2/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_h2/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_mysql/","text":"Getting Started with MySQL First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" dialect = \"app.cash.sqldeight:mysql-dialect:2.0.0-alpha04\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"app.cash.sqldeight:mysql-dialect:2.0.0-alpha04\" } } SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ). Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_mysql/#getting-started-with-mysql","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" dialect = \"app.cash.sqldeight:mysql-dialect:2.0.0-alpha04\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"app.cash.sqldeight:mysql-dialect:2.0.0-alpha04\" } } SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ).","title":"Getting Started with MySQL"},{"location":"jvm_mysql/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_mysql/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_mysql/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_mysql/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_mysql/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_mysql/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"jvm_mysql/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"jvm_mysql/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"jvm_mysql/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"jvm_mysql/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"jvm_mysql/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"jvm_mysql/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"jvm_mysql/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"jvm_mysql/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"jvm_mysql/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"jvm_mysql/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"jvm_mysql/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"jvm_mysql/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"jvm_mysql/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"jvm_mysql/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"jvm_mysql/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"jvm_mysql/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_mysql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_mysql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_mysql/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_mysql/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_mysql/query_arguments/","text":"Bind Args .sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"jvm_mysql/query_arguments/#bind-args","text":".sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_mysql/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_mysql/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_mysql/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_mysql/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_mysql/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"jvm_mysql/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_mysql/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_mysql/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_mysql/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_mysql/types/","text":"MySQL Types SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_medium_int MEDIUMINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Double some_dec DEC , -- Retrieved as Double some_fixed FIXED , -- Retrieved as Double some_numeric NUMERIC , -- Retrieved as Double some_float FLOAT , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_datetime DATETIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_year YEAR , -- Retrieved as String some_char CHAR , -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_tiny_text TINYTEXT , -- Retrieved as String some_text TEXT , -- Retrieved as String some_medium_text MEDIUMTEXT , -- Retrieved as String some_long_text LONGTEXT , -- Retrieved as String some_enum ENUM , -- Retrieved as String some_set SET , -- Retrieved as String some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_blob BLOB ( 8 , 8 ), -- Retrieved as ByteArray some_binary BINARY , -- Retrieved as ByteArray some_json JSON , -- Retrieved as String some_boolean BOOLEAN , -- Retrieved as Boolean ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_mysql/types/#mysql-types","text":"SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_medium_int MEDIUMINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Double some_dec DEC , -- Retrieved as Double some_fixed FIXED , -- Retrieved as Double some_numeric NUMERIC , -- Retrieved as Double some_float FLOAT , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_datetime DATETIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_year YEAR , -- Retrieved as String some_char CHAR , -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_tiny_text TINYTEXT , -- Retrieved as String some_text TEXT , -- Retrieved as String some_medium_text MEDIUMTEXT , -- Retrieved as String some_long_text LONGTEXT , -- Retrieved as String some_enum ENUM , -- Retrieved as String some_set SET , -- Retrieved as String some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_blob BLOB ( 8 , 8 ), -- Retrieved as ByteArray some_binary BINARY , -- Retrieved as ByteArray some_json JSON , -- Retrieved as String some_boolean BOOLEAN , -- Retrieved as Boolean );","title":"MySQL Types"},{"location":"jvm_mysql/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_mysql/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_mysql/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_postgresql/","text":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT PostgreSQL is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi Getting Started with PostgreSQL First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" dialect = \"app.cash.sqldeight:postgres-dialect:2.0.0-alpha04\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"app.cash.sqldeight:postgres-dialect:2.0.0-alpha04\" } } SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ). Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_postgresql/#in-development","text":"PostgreSQL is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT"},{"location":"jvm_postgresql/#getting-started-with-postgresql","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" dialect = \"app.cash.sqldeight:postgres-dialect:2.0.0-alpha04\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"app.cash.sqldeight:postgres-dialect:2.0.0-alpha04\" } } SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll progressively apply migrations over time to update your database's schema. In SQLDelight, these approaches translate to either writing your table definitions in .sq files for a \" Fresh Schema \", or by writing migration statements in .sqm files for a \" Migration Schema \". In both cases, your SQL queries will be written in .sq files ( as shown here ).","title":"Getting Started with PostgreSQL"},{"location":"jvm_postgresql/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_postgresql/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: Kotlin Groovy sqldelight { database ( \"Database\" ) { ... sourceFolders = listOf ( \"sqldelight\" ) deriveSchemaFromMigrations = true } } sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src `-- main `-- sqldelight |-- v1__backend.sqm `-- v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_postgresql/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:jdbc-driver:2.0.0-alpha04\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_postgresql/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_postgresql/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_postgresql/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"jvm_postgresql/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"jvm_postgresql/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"jvm_postgresql/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"jvm_postgresql/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"jvm_postgresql/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"jvm_postgresql/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"jvm_postgresql/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"jvm_postgresql/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"jvm_postgresql/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"jvm_postgresql/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"jvm_postgresql/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"jvm_postgresql/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"jvm_postgresql/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"jvm_postgresql/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"jvm_postgresql/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"jvm_postgresql/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_postgresql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_postgresql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_postgresql/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_postgresql/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_postgresql/query_arguments/","text":"Bind Args .sq files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"jvm_postgresql/query_arguments/#bind-args","text":".sq files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_postgresql/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_postgresql/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_postgresql/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_postgresql/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_postgresql/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"jvm_postgresql/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_postgresql/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_postgresql/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_postgresql/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_postgresql/types/","text":"PostgreSQL Types SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_smallint SMALLINT , -- Retrieved as Short some_int2 INT2 , -- Retrieved as Short some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_int4 INT4 , -- Retrieved as Int some_bigint BIGINT , -- Retrieved as Long some_int8 INT8 , -- Retrieved as Long some_numeric NUMERIC , -- Retrieved as Double some_decimal DECIMAL , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_float4 FLOAT4 , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_float8 FLOAT8 , -- Retrieved as Double some_smallserial SMALLSERIAL , -- Retrieved as Short some_serial2 SERIAL2 , -- Retrieved as Short some_serial SERIAL , -- Retrieved as Int some_serial4 SERIAL4 , -- Retrieved as Int some_bigserial BIGSERIAL , -- Retrieved as Long some_serial8 SERIAL8 , -- Retrieved as Long some_character CHARACTER , -- Retrieved as String some_char CHAR , -- Retrieved as String some_char_var CHARACTER VARYING ( 16 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_text TEXT , -- Retrieved as String some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_json JSON -- Retrieved as String ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_postgresql/types/#postgresql-types","text":"SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_smallint SMALLINT , -- Retrieved as Short some_int2 INT2 , -- Retrieved as Short some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_int4 INT4 , -- Retrieved as Int some_bigint BIGINT , -- Retrieved as Long some_int8 INT8 , -- Retrieved as Long some_numeric NUMERIC , -- Retrieved as Double some_decimal DECIMAL , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_float4 FLOAT4 , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_float8 FLOAT8 , -- Retrieved as Double some_smallserial SMALLSERIAL , -- Retrieved as Short some_serial2 SERIAL2 , -- Retrieved as Short some_serial SERIAL , -- Retrieved as Int some_serial4 SERIAL4 , -- Retrieved as Int some_bigserial BIGSERIAL , -- Retrieved as Long some_serial8 SERIAL8 , -- Retrieved as Long some_character CHARACTER , -- Retrieved as String some_char CHAR , -- Retrieved as String some_char_var CHARACTER VARYING ( 16 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_text TEXT , -- Retrieved as String some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_json JSON -- Retrieved as String );","title":"PostgreSQL Types"},{"location":"jvm_postgresql/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_postgresql/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_postgresql/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . String ; import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_sqlite/","text":"Getting Started on JVM with SQLite First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"jvm_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"jvm_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"jvm_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"jvm_sqlite/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"jvm_sqlite/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"jvm_sqlite/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"jvm_sqlite/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"jvm_sqlite/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"jvm_sqlite/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"jvm_sqlite/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"jvm_sqlite/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"jvm_sqlite/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"jvm_sqlite/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"jvm_sqlite/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"jvm_sqlite/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"jvm_sqlite/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"jvm_sqlite/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"jvm_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/migrations/","text":"Migrations An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration. Code Migrations If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#migrations","text":"An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"jvm_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"jvm_sqlite/migrations/#code-migrations","text":"If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Code Migrations"},{"location":"jvm_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"jvm_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_sqlite/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"jvm_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"jvm_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-alpha04\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"jvm_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray ); Primitives A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"jvm_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray );","title":"SQLite Types"},{"location":"jvm_sqlite/types/#primitives","text":"A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Primitives"},{"location":"jvm_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"multiplatform_sqlite/","text":"Getting Started with Multiplatform First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/commonMain/sqldelight . Typically the first statement in the SQL file creates a table. -- src/commonMain/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation ( \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" ) } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation ( \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" ) } sourceSets . jvmMain . dependencies { implementation ( \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" ) } } kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" } sourceSets . jvmMain . dependencies { implementation \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" } } // in src/commonMain/kotlin expect class DriverFactory { expect fun createDriver (): SqlDriver } fun createDatabase ( driverFactory ): Database { val driver = driverFactory . createDriver () val database = Database ( driver ) // Do more work with the database (see below). } // in src/androidMain/kotlin actual class DriverFactory ( private val context : Context ) { actual fun createDriver (): SqlDriver { return AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) } } // in src/nativeMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { return NativeSqliteDriver ( Database . Schema , \"test.db\" ) } } // in src/jvmMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) return driver } } For use with the SqlJs driver, see here . SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"multiplatform_sqlite/#getting-started-with-multiplatform","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/commonMain/sqldelight . Typically the first statement in the SQL file creates a table. -- src/commonMain/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation ( \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" ) } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation ( \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" ) } sourceSets . jvmMain . dependencies { implementation ( \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" ) } } kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"app.cash.sqldelight:android-driver:2.0.0-alpha04\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" } sourceSets . jvmMain . dependencies { implementation \"app.cash.sqldelight:sqlite-driver:2.0.0-alpha04\" } } // in src/commonMain/kotlin expect class DriverFactory { expect fun createDriver (): SqlDriver } fun createDatabase ( driverFactory ): Database { val driver = driverFactory . createDriver () val database = Database ( driver ) // Do more work with the database (see below). } // in src/androidMain/kotlin actual class DriverFactory ( private val context : Context ) { actual fun createDriver (): SqlDriver { return AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) } } // in src/nativeMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { return NativeSqliteDriver ( Database . Schema , \"test.db\" ) } } // in src/jvmMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) return driver } } For use with the SqlJs driver, see here . SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started with Multiplatform"},{"location":"multiplatform_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"multiplatform_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"multiplatform_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"multiplatform_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"multiplatform_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"multiplatform_sqlite/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"multiplatform_sqlite/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"multiplatform_sqlite/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"multiplatform_sqlite/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"multiplatform_sqlite/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"multiplatform_sqlite/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"multiplatform_sqlite/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"multiplatform_sqlite/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"multiplatform_sqlite/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"multiplatform_sqlite/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"multiplatform_sqlite/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"multiplatform_sqlite/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"multiplatform_sqlite/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"multiplatform_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"multiplatform_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/migrations/","text":"Migrations An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration. Code Migrations If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#migrations","text":"An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"multiplatform_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"multiplatform_sqlite/migrations/#code-migrations","text":"If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Code Migrations"},{"location":"multiplatform_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"multiplatform_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"multiplatform_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"multiplatform_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"multiplatform_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"multiplatform_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"multiplatform_sqlite/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"multiplatform_sqlite/resources/","text":"Other Resources Guides Introduction to Multiplatform Persistence with SQLDelight Multiplatform Persistence with SQLDelight Samples https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web) https://github.com/JakeWharton/SdkSearch (Android/Web) https://github.com/saket/press (Android/macOS) https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web) https://github.com/russhwolf/To-Do (Android/iOS using Compose/SwiftUI)","title":"Resources"},{"location":"multiplatform_sqlite/resources/#other-resources","text":"","title":"Other Resources"},{"location":"multiplatform_sqlite/resources/#guides","text":"Introduction to Multiplatform Persistence with SQLDelight Multiplatform Persistence with SQLDelight","title":"Guides"},{"location":"multiplatform_sqlite/resources/#samples","text":"https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web) https://github.com/JakeWharton/SdkSearch (Android/Web) https://github.com/saket/press (Android/macOS) https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web) https://github.com/russhwolf/To-Do (Android/iOS using Compose/SwiftUI)","title":"Samples"},{"location":"multiplatform_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"multiplatform_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"multiplatform_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"multiplatform_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"multiplatform_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray ); Primitives A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"multiplatform_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray );","title":"SQLite Types"},{"location":"multiplatform_sqlite/types/#primitives","text":"A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Primitives"},{"location":"multiplatform_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"multiplatform_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"native_sqlite/","text":"Getting started on Kotlin Native with SQLDelight First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation ( \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" ) } } kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" } } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" ) Kotlin/Native Memory Models The SQLDelight native driver is compatible with both the original strict memory model and the updated memory model. However, it is optimized for the new memory model, and as most of the official Jetbrains libraries will be gradually dropping support for the strict memory model, support for the strict memory model may be deprecated or removed in future releases. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality. Reader Connection Pools Disk databases can (optionally) have multiple reader connections. To configure the reader pool, pass the maxReaderConnections parameter to the various constructors of NativeSqliteDriver : val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" , maxReaderConnections = 4 ) Reader connections are only used to run queries outside of a transaction. Any write calls, and anything in a transaction, uses a single connection dedicated to transactions.","title":"Getting Started"},{"location":"native_sqlite/#getting-started-on-kotlin-native-with-sqldelight","text":"First apply the gradle plugin in your project. Kotlin Groovy plugins { id ( \"app.cash.sqldelight\" ) version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { database ( \"Database\" ) { packageName = \"com.example\" } } plugins { id \"app.cash.sqldelight\" version \"2.0.0-alpha04\" } repositories { google () mavenCentral () } sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER PRIMARY KEY NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Kotlin Groovy kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation ( \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" ) } } kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"app.cash.sqldelight:native-driver:2.0.0-alpha04\" } } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" )","title":"Getting started on Kotlin Native with SQLDelight"},{"location":"native_sqlite/#kotlinnative-memory-models","text":"The SQLDelight native driver is compatible with both the original strict memory model and the updated memory model. However, it is optimized for the new memory model, and as most of the official Jetbrains libraries will be gradually dropping support for the strict memory model, support for the strict memory model may be deprecated or removed in future releases. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Kotlin/Native Memory Models"},{"location":"native_sqlite/#reader-connection-pools","text":"Disk databases can (optionally) have multiple reader connections. To configure the reader pool, pass the maxReaderConnections parameter to the various constructors of NativeSqliteDriver : val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" , maxReaderConnections = 4 ) Reader connections are only used to run queries outside of a transaction. Any write calls, and anything in a transaction, uses a single connection dedicated to transactions.","title":"Reader Connection Pools"},{"location":"native_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"native_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: Kotlin Groovy kotlin { sourceSets . commonMain . dependencies { implementation ( \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" ) } } kotlin { sourceSets . commonMain . dependencies { implementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-alpha04\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"native_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"native_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"native_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. SQLDelight Configuration database Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } } linkSqlite Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true Database Configuration packageName Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\" sourceFolders Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ] schemaOutputDirectory Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) dependency Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" ) dialect Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04' verifyMigrations Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true treatNullAsUnknownForEquality Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true generateAsync Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true deriveSchemaFromMigrations Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true Schema Dependencies You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Gradle"},{"location":"native_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL.","title":"Gradle"},{"location":"native_sqlite/gradle/#sqldelight-configuration","text":"","title":"SQLDelight Configuration"},{"location":"native_sqlite/gradle/#database","text":"Configures SQLDelight to create a database with the given name. Kotlin Groovy sqldelight { database ( \"MyDatabase\" ) { // Database configuration here } } sqldelight { MyDatabase { // Database configuration here } }","title":"database"},{"location":"native_sqlite/gradle/#linksqlite","text":"Type: Boolean For native targets. Whether sqlite should be automatically linked. Defaults to true. linkSqlite = true","title":"linkSqlite"},{"location":"native_sqlite/gradle/#database-configuration","text":"","title":"Database Configuration"},{"location":"native_sqlite/gradle/#packagename","text":"Type: String Package name used for the database class. Kotlin Groovy packageName = \"com.example.db\" packageName = \"com.example.db\"","title":"packageName"},{"location":"native_sqlite/gradle/#sourcefolders","text":"Type: Collection<String> An collection of folders that the plugin will look in for your .sq and .sqm files. These folder paths are relative to your existing source set, so if you specify listOf(\"db\") then the plugin will look into src/main/db or src/commondMain/db . Defaults to listOf(\"sqldelight\") . Kotlin Groovy sourceFolders = listOf ( \"db\" ) sourceFolders = [ 'db' ]","title":"sourceFolders"},{"location":"native_sqlite/gradle/#schemaoutputdirectory","text":"Type: File The directory where .db schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema. Defaults to null . If null , the migration verification tasks will not be created. Kotlin Groovy schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" )","title":"schemaOutputDirectory"},{"location":"native_sqlite/gradle/#dependency","text":"Type: Project Optionally specify schema dependencies on other gradle projects (see below) . Kotlin Groovy dependency ( project ( \":other-project\" )) dependency project ( \":other-project\" )","title":"dependency"},{"location":"native_sqlite/gradle/#dialect","text":"Type: String or Provider<MinimalExternalModuleDependency> The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as app.cash.sqldelight:{dialect module}:2.0.0-alpha04 . See below for available dialects. For Android projects, the SQLite version is automatically selected based on your minSdk . Otherwise defaults to SQLite 3.18. Available dialects: HSQL: hsql-dialect MySQL: mysql-dialect PostgreSQL: postgresql-dialect SQLite 3.18: sqlite-3-18-dialect SQLite 3.24: sqlite-3-24-dialect SQLite 3.25: sqlite-3-25-dialect SQLite 3.30: sqlite-3-30-dialect SQLite 3.33: sqlite-3-33-dialect SQLite 3.35: sqlite-3-35-dialect SQLite 3.38: sqlite-3-38-dialect Kotlin Groovy dialect ( \"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04\" ) dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-alpha04'","title":"dialect"},{"location":"native_sqlite/gradle/#verifymigrations","text":"Type: Boolean If set to true, migration files will fail during the build process if there are any errors in them. Defaults to false . Kotlin Groovy verifyMigrations = true verifyMigrations = true","title":"verifyMigrations"},{"location":"native_sqlite/gradle/#treatnullasunknownforequality","text":"Type: Boolean If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using IS . Defaults to false . Kotlin Groovy treatNullAsUnknownForEquality = true treatNullAsUnknownForEquality = true","title":"treatNullAsUnknownForEquality"},{"location":"native_sqlite/gradle/#generateasync","text":"Type: Boolean If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers. Kotlin Groovy generateAsync = true generateAsync = true","title":"generateAsync"},{"location":"native_sqlite/gradle/#deriveschemafrommigrations","text":"Type: Boolean If set to true, the schema for your database will be derived from your .sqm files as if each migration had been applied. If false, your schema is defined in .sq files. Defaults to false. Kotlin Groovy deriveSchemaFromMigrations = true deriveSchemaFromMigrations = true","title":"deriveSchemaFromMigrations"},{"location":"native_sqlite/gradle/#schema-dependencies","text":"You can specify schema dependencies on another module: Kotlin Groovy // project-a/build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.projecta\" dependency ( project ( \":ProjectB\" )) } } // project-a/build.gradle sqldelight { MyDatabase { packageName = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: Kotlin Groovy // project-b/build.gradle.kts sqldelight { // Same database name database ( \"MyDatabase\" ) { package = \"com.example.projectb\" } } // project-b/build.gradle sqldelight { // Same database name MyDatabase { package = \"com.example.projectb\" } } If you use deriveSchemaFromMigrations = true , every module depending on this module must also enable this feature.","title":"Schema Dependencies"},{"location":"native_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once inside a transaction: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"native_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"native_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"native_sqlite/migrations/","text":"Migrations An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration. Code Migrations If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Migrations"},{"location":"native_sqlite/migrations/#migrations","text":"An .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same sqldelight folder as your .sq files: src \u2514\u2500 main \u2514\u2500 sqdelight \u251c\u2500 com/example/hockey | \u251c\u2500 Team.sq | \u2514\u2500 Player.sq \u2514\u2500 migrations \u251c\u2500 1.sqm \u2514\u2500 2.sqm If the driver supports it, migrations are run in a transaction. You should not surround your migrations in BEGIN/END TRANSACTION , as this can cause a crash with some drivers.","title":"Migrations"},{"location":"native_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"native_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"native_sqlite/migrations/#code-migrations","text":"If you run your migration from code and would like to perform data migrations you can use the Database.Schema.migrateWithCallbacks api: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersion ( 3 ) { database . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) Alternatively, it is often useful to receive the SqlDriver as a parameter. In those cases, you can use AfterVersionWithDriver class instead: Database . Schema . migrateWithCallbacks ( driver = database , oldVersion = 0 , newVersion = Database . Schema . version , AfterVersionWithDriver ( 3 ) { it . execute ( null , \"INSERT INTO test (value) VALUES('hello')\" , 0 ) }, ) In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.","title":"Code Migrations"},{"location":"native_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell ) Input Sanitization SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Arguments"},{"location":"native_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"native_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"native_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"native_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"native_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"native_sqlite/query_arguments/#input-sanitization","text":"SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.","title":"Input Sanitization"},{"location":"native_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"native_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player > () database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithResult function. val players : List < Player > = database . playerQueries . transactionWithResult { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"native_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted : Int = database . playerQueries . transactionWithResult { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"native_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \" ${ players . size } players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"native_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray ); Primitives A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"native_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray );","title":"SQLite Types"},{"location":"native_sqlite/types/#primitives","text":"A sibling module that adapts primitives for your convenience. Kotlin Groovy dependencies { implementation ( \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" ) } dependencies { implementation \"app.cash.sqldelight:primitive-adapters:2.0.0-alpha04\" } The following adapters exist: BooleanColumnAdapter \u2014 Retrieves kotlin.Boolean for an SQL type implicitly stored as kotlin.Long FloatColumnAdapter \u2014 Retrieves kotlin.Float for an SQL type implicitly stored as kotlin.Double IntColumnAdapter \u2014 Retrieves kotlin.Int for an SQL type implicitly stored as kotlin.Long ShortColumnAdapter \u2014 Retrieves kotlin.Short for an SQL type implicitly stored as kotlin.Long","title":"Primitives"},{"location":"native_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . String ; import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String > , String > { override fun decode ( databaseValue : String ) = if ( databaseValue . isEmpty ()) { listOf () } else { databaseValue . split ( \",\" ) } override fun encode ( value : List < String > ) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"native_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"}]}